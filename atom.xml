<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ahonn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.ahonn.me/"/>
  <updated>2018-09-14T16:12:56.000Z</updated>
  <id>http://www.ahonn.me/</id>
  
  <author>
    <name>Ahonn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 函数式编程笔记</title>
    <link href="http://www.ahonn.me/2018/09/15/javascript-functional-programming-notes/"/>
    <id>http://www.ahonn.me/2018/09/15/javascript-functional-programming-notes/</id>
    <published>2018-09-14T16:01:27.000Z</published>
    <updated>2018-09-14T16:12:56.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为 <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/cotent/" target="_blank" rel="noopener">JS 函数式编程指南</a>  笔记</p></blockquote><h2 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h2><p>当我们说函数是“一等公民”的时候，我们实际上说的是它们跟其他对象都一样，你可以像对待其他数据结构一样对待它们。</p><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>相同的输入产生相同的输出，并且没有副作用，即为纯函数。例如 <code>Array.prototype.slice</code> 是纯函数，而 <code>Array.prototype.splice</code> 不是纯函数。</p><p>只要函数跟外界环境发生交互，就是有副作用。但并不是说要禁止副作用，函数式的编程哲学是假定副作用是造成不正当行为的主要原因。</p><p>纯函数的好处：</p><ul><li>可缓存性 Cacheable</li><li>可移植性 Portable</li><li>可测试性 Testable</li><li>合理性 Reasonable (引用透明)</li></ul><a id="more"></a><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>只传递一个参数来调用它，然后返回另一个函数处理剩下的参数，称为柯离化，也叫做局部调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">'lodash/fp'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = _.curry(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add2 = add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add2(<span class="number">3</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>通过组合两个或多个函数返回一个新的函数，例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">n</span> =&gt;</span> n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">n</span> =&gt;</span> n * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn = compomse(f, g);</span><br><span class="line"></span><br><span class="line">fn(<span class="number">1</span>); <span class="comment">// =&gt; f(g(1)) =&gt; 4</span></span><br></pre></td></tr></table></figure><p>在 compomse 中，g 将先于 f 执行，因此创建了一个从右到左的数据流。</p><p><em>结合律：compomse(f, compomse(g, h)) 等同于 compomse(compomse(f, g), h)</em></p><h2 id="pointfree"><a href="#pointfree" class="headerlink" title="pointfree"></a>pointfree</h2><pre><code>“Love means never having to say you&apos;re sorry”</code></pre><p>pointfree 模式是指永远不需要声明数据。</p><p>以一个不恰当的代码比喻：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="function"><span class="params">name</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// not pointfree</span></span><br><span class="line"><span class="keyword">const</span> sayHello = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> hello(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointfree</span></span><br><span class="line"><span class="keyword">const</span> sayHello = hello</span><br></pre></td></tr></table></figure></p><p>PS: 个人理解，pointfree 即是指函数仅只是其他函数的组合，并不需要指定外部的数据，函数中也不需要传入外部变量。<br>但这无法绝对避免，例如获取某个时间字符串的时间戳：<code>const timestamp = (date) =&gt; (new Date(date)).getTime()</code>。</p><h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>在函数的组合中需要进行 debug 的话，可以使用 <code>trace</code> 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trace = curry(<span class="function">(<span class="params">tag, value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tag, value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将 <code>trace</code> 函数插入到 <code>compomse</code> 中即可检查上一个函数返回值是否正确。</p><h2 id="identity"><a href="#identity" class="headerlink" title="identity"></a>identity</h2><p>范畴学中独特的态射，这个函数接受随便什么东西，然后原封不动的吐出来。一个假装自己是普通数据的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identity = <span class="function"><span class="params">x</span> =&gt;</span> x;</span><br></pre></td></tr></table></figure><p>identity 函数可以一起使用，但是看起来好像是没有卵用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compomse(identity, f) == compomse(f, identity) == f</span><br></pre></td></tr></table></figure></p><h2 id="类型签名"><a href="#类型签名" class="headerlink" title="类型签名"></a>类型签名</h2><p>接受具体类型，返回具体类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello::String -&gt; String</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="function"><span class="params">name</span> =&gt;</span> <span class="string">`hello <span class="subst">$&#123;name&#125;</span>`</span>;</span><br></pre></td></tr></table></figure></p><p>接受任意类型，并返回相同类型：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// identity::a -&gt; a</span></span><br><span class="line"><span class="keyword">const</span> identity = <span class="function"><span class="params">n</span> =&gt;</span> n</span><br></pre></td></tr></table></figure></p><p>接受函数参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map::(a -&gt; b) -&gt; ![pic](a) -&gt; ![pic](b)</span></span><br><span class="line"><span class="keyword">const</span> map = curry(<span class="function">(<span class="params">f, xs</span>) =&gt;</span> xs.map(f));</span><br></pre></td></tr></table></figure></p><h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort::Ord a =&gt; ![pic](a) =&gt; ![pic](a)</span></span><br><span class="line"><span class="keyword">const</span> sort = balabala</span><br></pre></td></tr></table></figure><p>胖箭头的左边表明 a 一定是一个 Ord 对象，也就是说 a 必须要实现 Ord 接口（可排序）。</p><p>通过这种方式能够限制函数的作用范围，这种接口声明叫做类型约束。</p><h2 id="functor"><a href="#functor" class="headerlink" title="functor"></a>functor</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Functor = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.__value = x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Functor.of = <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">new</span> Functor(x);</span><br><span class="line"></span><br><span class="line">Functor.prototype.map = <span class="function"><span class="params">f</span> =&gt;</span> Functor.of(f(<span class="keyword">this</span>.__value));</span><br></pre></td></tr></table></figure><p>functor 是实现了 <code>map</code> 函数，并遵守某些特点规则的容器类型，具有 <code>mappable</code> 的特点（类似于 Promise 的 thenable）。</p><h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><p>Maybe 是另一种 functor，实际上只是多了空值检查。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Maybe = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.__value = x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Maybe.of = <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">new</span> Maybe(x);</span><br><span class="line"></span><br><span class="line">Maybe.prototype.isNothing = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.__value === <span class="literal">null</span> || <span class="keyword">this</span>.__value === <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">Maybe.prototype.map = <span class="function"><span class="params">f</span> =&gt;</span> <span class="keyword">this</span>.isNothing() ? Maybe.of(<span class="literal">null</span>) : Maybe.of(f(<span class="keyword">this</span>.__value));</span><br></pre></td></tr></table></figure><p>Maybe 使得在 <code>map</code> 调用中产生 null 或者 undefined 时不会爆出错误，而是最后返回 <code>Maybe.of(null)</code>。</p><h3 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h3><p>Either 又是另外一种 functor, 不同于正常的 functor, Either 不管怎么 map 都不会改变自己的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Either = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.__value = x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Either.of = <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">new</span> Either(x);</span><br><span class="line"></span><br><span class="line">Either.prototype.map = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>;</span><br></pre></td></tr></table></figure><p>Either 用于错误处理，当出现错误时我们返回一个 <code>Either.of(error)</code>, 它将把错误带到最后，并显示出来。<br>实际上它就是一个错误消息的 functor, 只是指不会被改变。</p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>IO 又又是另外一种 functor, 与最普通的 functor 的差别是，IO 的 <code>__value</code> 是一个函数（不过，我们把它当成是数据）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> IO = <span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.unsafaPerfromIO = f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">IO.of = <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">new</span> IO(<span class="function"><span class="params">()</span> =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">IO.prototype.map = <span class="function"><span class="params">f</span> =&gt;</span> IO.of(compomse(f, <span class="keyword">this</span>.unsafaPerfromIO));</span><br></pre></td></tr></table></figure><p>IO 把非纯的动作捕获到包裹函数中，延迟执行非纯的动作。并且，假装 IO 的返回指不是包裹函数本身，而是包裹函数执行后的返回值。</p><p>当需要获取 IO 的值的时候，就执行 <code>IO.unsafaPerfromIO()</code>（此时才会执行整个过程 map by map）。</p><h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>  pointed functor 是指实现了 <code>of</code> 方法的 functor</p><p>  monad 是可以变扁的 pointed functor</p><p>monad 主要的使用场景是用来解决嵌套的 functor。</p><p>一个 functor，只要它定义了一个 <code>join</code> 方法和 <code>of</code> 方法，并遵守一些定律，那么它就是一个 monad。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getItem = <span class="function"><span class="params">key</span> =&gt;</span> IO.of(<span class="function"><span class="params">()</span> =&gt;</span> localStorage.getItem(key));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> log = x = IO.of(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> printItem = compomse(join, map(log), getItem);</span><br><span class="line"></span><br><span class="line">printItem(<span class="string">'xxx'</span>).unsafaPerfromIO();</span><br></pre></td></tr></table></figure><h3 id="chain-函数"><a href="#chain-函数" class="headerlink" title="chain 函数"></a>chain 函数</h3><p>chain 函数是 functor map 之后 join 的抽象行为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chain = curry(<span class="function">(<span class="params">f, m</span>) =&gt;</span> m.map(f).join());</span><br></pre></td></tr></table></figure></p><p>PS: 其实没有啥用，只是把 <code>compomse(join, map(log), ...)</code> 变成了 <code>compomse(chain(log), ...)</code></p><h2 id="Applicative-Functor"><a href="#Applicative-Functor" class="headerlink" title="Applicative Functor"></a>Applicative Functor</h2><p>applicative functor 能够以一种简明扼要的方式把一个 functor 的值应用到另外一个 functor 上。</p><p>  applicative functor 是实现了 <code>ap</code> 方法的 pointed functor</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// applicative</span></span><br><span class="line">Functor.prototype.ap = <span class="function"><span class="params">other</span> =&gt;</span> other.map(<span class="keyword">this</span>.__value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Functor.of(add(2)).ap(Functor.of(3));</span></span><br></pre></td></tr></table></figure><p><code>Functor.of(x).map(f)</code> 等价于 <code>Functor.of(f).ap(Functor.of(x))</code>。</p><h3 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h3><p>以 pointfree 的方式调用 applicative functor。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> liftA2 = curry(<span class="function">(<span class="params">f, functor1, functor2</span>) =&gt;</span> functor1.map(f).ap(functor2));</span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>  haskell 中可以使用 <code>&lt;$&gt;</code> 表示 <code>map</code>, <code>&lt;*&gt;</code> 表示 <code>ap</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Functor.of(<span class="number">2</span>).map(add).ap(Functor.of(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// map(add, Functor.of(2)).ap(Functor.of(3));</span></span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">add</span> &lt;$&gt; <span class="type">Functor</span> <span class="number">2</span> &lt;*&gt; <span class="type">Functor</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="定律"><a href="#定律" class="headerlink" title="定律"></a>定律</h2><ul><li>同一：<code>A.of(id).ap(v) == v</code></li><li>同态：<code>A.of(f).ap(A.of(x)) == A.of(f(x))</code></li><li>互换：<code>v.ap(A.of(x)) == A.of(f =&gt; f(x)).ap(x)</code></li><li>组合：<code>A.of(compomse).ap(u).ap(v).ap(w) == u.ap(v.ap(w))</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文为 &lt;a href=&quot;https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/cotent/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JS 函数式编程指南&lt;/a&gt;  笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;函数是一等公民&quot;&gt;&lt;a href=&quot;#函数是一等公民&quot; class=&quot;headerlink&quot; title=&quot;函数是一等公民&quot;&gt;&lt;/a&gt;函数是一等公民&lt;/h2&gt;&lt;p&gt;当我们说函数是“一等公民”的时候，我们实际上说的是它们跟其他对象都一样，你可以像对待其他数据结构一样对待它们。&lt;/p&gt;
&lt;h2 id=&quot;纯函数&quot;&gt;&lt;a href=&quot;#纯函数&quot; class=&quot;headerlink&quot; title=&quot;纯函数&quot;&gt;&lt;/a&gt;纯函数&lt;/h2&gt;&lt;p&gt;相同的输入产生相同的输出，并且没有副作用，即为纯函数。例如 &lt;code&gt;Array.prototype.slice&lt;/code&gt; 是纯函数，而 &lt;code&gt;Array.prototype.splice&lt;/code&gt; 不是纯函数。&lt;/p&gt;
&lt;p&gt;只要函数跟外界环境发生交互，就是有副作用。但并不是说要禁止副作用，函数式的编程哲学是假定副作用是造成不正当行为的主要原因。&lt;/p&gt;
&lt;p&gt;纯函数的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可缓存性 Cacheable&lt;/li&gt;
&lt;li&gt;可移植性 Portable&lt;/li&gt;
&lt;li&gt;可测试性 Testable&lt;/li&gt;
&lt;li&gt;合理性 Reasonable (引用透明)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://www.ahonn.me/categories/technology/"/>
    
      <category term="读书笔记" scheme="http://www.ahonn.me/categories/technology/reading/"/>
    
    
      <category term="JavaScript" scheme="http://www.ahonn.me/tags/JavaScript/"/>
    
      <category term="函数式编程" scheme="http://www.ahonn.me/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>我的 2017</title>
    <link href="http://www.ahonn.me/2017/12/29/my-2017/"/>
    <id>http://www.ahonn.me/2017/12/29/my-2017/</id>
    <published>2017-12-29T15:35:09.000Z</published>
    <updated>2018-09-14T16:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>恍恍惚惚的，又一年过去了，又到了写年终总结的时间了。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>说到学习，这一年学到最多的是开始慢慢的脱离某些学生思维。开始全面的思考问题，对做什么事情都先有一个计划，而不是一股脑的做。就像是编程，应该大部分时间用来思考，而编码实现只是最后的一步操作。</p><p>开始慢慢的接触一些能够提升效率的工具或者方法，例如年初开始学 vim，虽然说写代码的时候效率的瓶颈并不在敲代码的速度上，但是 vim 的确对编程的体验提高不少。</p><p>下半年开始学着用番茄工作法管理时间，提高注意力。目前来说效果还不错，就是有时候番茄间的休息我还是继续在干自己的时候，这一点做得不是很好。毕竟代码一写起来并不是那么好停的。</p><p>虽然今年不是太关注 commit，但是依旧还是有着蛮多的记录的。写得比较随性，但是因为太久不写自己会觉得堕落，觉得好像少了点什么，所以总体也只是比去年少了那么一点。</p><p><img src="https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/7j9aq.jpg" alt="2017 commit"></p><a id="more"></a><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>今年也是阅读了不少的书。除了看一些技术相关的书籍之外，看了东野圭吾的几本小说，还有王小波的《沉默的大多数》啥的。<br>去年立的 flag 说看完 SICP，今年依旧还是没有完成，至今只看到第四章。最近又开始重新看这本书，希望明年能够看完它。嗯，对。希望可以。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>终于，我也开始能把工作这一项加入到年终总结中了。</p><p>年初开始为了这一年的校招做准备，最后有惊无险的进了阿里。期间的经历很奇妙，神奇的通过了一轮轮面试，自己竟然有点不敢相信。接着暑假跑去杭州实习了近两个月时间。</p><p>第一次独自一人在异乡生活，很多事情刚开始非常不习惯，勉强能够照顾自己。生活质量嘛，就只能呵呵了～在阿里实习期间学到了非常多的东西，主管同事们都非常 nice，总之是一段非常好的经历。有点遗憾的是，杭州西湖也就是远远的瞟了一眼，明年一定要过去溜溜。</p><p>接着八月下旬转正答辩完就溜回学校了。还没有回到学校，主管电话过来说答辩过了，好棒～也就这样，我提前结束了我的校招旅程。虽然在此之前也投了其他厂的校招，但是既然已经拿到自己想去的阿里，便没有怎么去管其他的面试了。</p><h2 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h2><p>每年看其他师兄师姐的毕业照，总是会滋滋感叹时间过得真快。感叹几次之后，终于到了我了。那天大家都将头发梳成大人模样，穿上帅气西装，仿佛像是要郑重的像青春告别。但我却没有了看别人毕业照时的感叹。只是觉得，哦，我就要毕业了。</p><p>在大学里学到了非常非常多的东西，知道了应该怎么正确的处理各种事情。虽然没有经历什么大风大浪，但过得也算是精彩。</p><h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>今年除了去杭州实习之外，五一跟女朋友去了厦门逛了一圈。对厦门的第一印象是海风很大，虽然是五月，但感觉不到特别炎热。作为一个伪潮汕人，对这种闽南语地区还是非常有好感的～去了鼓浪屿，但是除了拍照蛮好看的之外，感觉并没有什么特别之处。游客太多了，我一向不是很喜欢这种人挤人的地方。</p><p>因为今年的嘻哈热潮，国庆的时候又跟女朋友跑去珠海，去沙滩音乐节听沙漠兄弟与 GAI。<br>老实说这是第一次去音乐节，感觉还是蛮嗨的。可惜的是，最喜欢的 Jony J 没有来这个音乐节。有时候还蛮想去学学如何 Rap，自己试着去写点歌的。但是，太懒了，哈哈哈。</p><p>很遗憾今年周杰伦在佛山的演唱会去不了（主要是没有钱），希望来年有演唱会的话能够到场点歌。</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>对于 2018 的计划，其实还是蛮多的，对未来充满了憧憬。</p><ul><li>跟女朋友在杭州工作生活能够顺顺利利</li><li>好好赚钱，减轻父母压力，照顾好弟弟</li><li>努力工作，在技术上能够更上一层楼</li><li>除了读技术书籍之外，读多一些其他书</li><li>拓展一下兴趣爱好，学会做饭</li><li>多运动，多健身，避免久坐</li></ul><p>虽说每年都会列未来一年的计划，但其实并不是每件事情都能做到最好。<br>希望自己能够尽自己所能，然后继续加油努力，继续前进。</p><p>happy coding &amp; happy living …</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;恍恍惚惚的，又一年过去了，又到了写年终总结的时间了。&lt;/p&gt;
&lt;h2 id=&quot;学习&quot;&gt;&lt;a href=&quot;#学习&quot; class=&quot;headerlink&quot; title=&quot;学习&quot;&gt;&lt;/a&gt;学习&lt;/h2&gt;&lt;p&gt;说到学习，这一年学到最多的是开始慢慢的脱离某些学生思维。开始全面的思考问题，对做什么事情都先有一个计划，而不是一股脑的做。就像是编程，应该大部分时间用来思考，而编码实现只是最后的一步操作。&lt;/p&gt;
&lt;p&gt;开始慢慢的接触一些能够提升效率的工具或者方法，例如年初开始学 vim，虽然说写代码的时候效率的瓶颈并不在敲代码的速度上，但是 vim 的确对编程的体验提高不少。&lt;/p&gt;
&lt;p&gt;下半年开始学着用番茄工作法管理时间，提高注意力。目前来说效果还不错，就是有时候番茄间的休息我还是继续在干自己的时候，这一点做得不是很好。毕竟代码一写起来并不是那么好停的。&lt;/p&gt;
&lt;p&gt;虽然今年不是太关注 commit，但是依旧还是有着蛮多的记录的。写得比较随性，但是因为太久不写自己会觉得堕落，觉得好像少了点什么，所以总体也只是比去年少了那么一点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/7j9aq.jpg&quot; alt=&quot;2017 commit&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://www.ahonn.me/categories/thinking/"/>
    
    
      <category term="年终总结" scheme="http://www.ahonn.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的 Mac</title>
    <link href="http://www.ahonn.me/2017/08/31/starting-from-scratch-mac/"/>
    <id>http://www.ahonn.me/2017/08/31/starting-from-scratch-mac/</id>
    <published>2017-08-31T06:56:58.000Z</published>
    <updated>2018-09-14T15:52:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天乱搞把电脑搞炸了，然后又误操作把系统格掉了。悲剧.. 除了在 Github 上的代码其他什么东西都没有了，心疼收集了那么久的电子书..</p><p>然后只能重装系统了，想想也好.. 是时候清理清理电脑了，正好借着这个机会整理一下。一开始使用简直烦到不行。没有安装罗技的鼠标驱动，鼠标按键无法打开 Launchpad，虽然可以用键盘快捷键，还是觉得很不舒服。还有一个很重点的是没有 Alfred，简直变得生活不能自理了。然后还有很多好用的工具要重新安装，找原先的 iTerm2 配色找了半天.. 所以说论备份的重要性..</p><a id="more"></a><p>只好从零开始了，下面是一些比较 Nice 的工具：</p><ul><li>Alfred：这个不用说，必备。没有这个我都不会用电脑了</li><li>Chrome：不解释，还好它能同步回之前的书签什么的</li><li>Shadowsocks：翻墙必备，没有它简直不像在上网</li><li>iHosts：修改 host 神器，开放必备</li><li>iPic：好用的图床工具，一键传上七牛</li><li>GhostSKB：自动根据 App 切换输入法</li><li>Dash：文档神器，搭配 Alfred 查 API so easy</li><li>Magnet：类似 Windows 上的窗口控制，触顶全屏等</li><li>Jietu：腾讯出品的截图软件，关掉其他截屏只用这个</li><li>Paste: 剪切板增强，体验超级好</li><li>Bartender：上面安装了那么多东西菜单栏一堆图标，用这个管理</li></ul><p>除了这些 App 还有非常重要的东西要安装：iTerm2 + zsh + oh my zsh，接着把 Neovim 装上下载之前的配置，调整 iTerm2 的配色（现在用的是这个 <a href="https://github.com/w0ng/vim-hybrid" target="_blank" rel="noopener">vim-hybrid</a>，主要是配合 Vim 的配色），现在可以美滋滋的写代码了～</p><p>等一下，我的 Chrome 插件呢？还好它们都回同步回来，谢天谢地。我的插件主要有这些：</p><ul><li>Octotree：Github 的侧栏目录树</li><li>GitHub Hovercard：Github Hover 卡片</li><li>OneTab：开太多标签又不想关掉的时候用这个</li><li>LassPass：密码同步，没钱买 1Password 的话用这个还是不错的</li><li>Advertising Terminator：屏蔽广告</li><li>Proxy SwitchyOmega：网络代理，主要配合 Shadowsocks</li><li>Vimium：浏览器 Vim 模式，可以丢掉鼠标了</li><li>Web Timer：统计上网花费时间</li></ul><p>然后就是一些经常用的 App 了，Quiver、Pocket、VS Code、网易云音乐之类的。差不多装了该装的东西了，用起来顺心多了… 剩下的就是之后慢慢优化了。</p><p>之前不知道 MacOS 有单用户模式..Google 出来的也没人提.. 等我格完盘之后才发现。另外其实我直接重装的话个人数据都还在的.. 说到底还是我自己作死点了格盘.. 说多了都是泪..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天乱搞把电脑搞炸了，然后又误操作把系统格掉了。悲剧.. 除了在 Github 上的代码其他什么东西都没有了，心疼收集了那么久的电子书..&lt;/p&gt;
&lt;p&gt;然后只能重装系统了，想想也好.. 是时候清理清理电脑了，正好借着这个机会整理一下。一开始使用简直烦到不行。没有安装罗技的鼠标驱动，鼠标按键无法打开 Launchpad，虽然可以用键盘快捷键，还是觉得很不舒服。还有一个很重点的是没有 Alfred，简直变得生活不能自理了。然后还有很多好用的工具要重新安装，找原先的 iTerm2 配色找了半天.. 所以说论备份的重要性..&lt;/p&gt;
    
    </summary>
    
      <category term="折腾工具" scheme="http://www.ahonn.me/categories/tool/"/>
    
    
      <category term="MacOS" scheme="http://www.ahonn.me/tags/MacOS/"/>
    
      <category term="Chrome" scheme="http://www.ahonn.me/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>最后我选择了 Quiver</title>
    <link href="http://www.ahonn.me/2017/08/17/finally-i-chose-quiver/"/>
    <id>http://www.ahonn.me/2017/08/17/finally-i-chose-quiver/</id>
    <published>2017-08-17T12:59:35.000Z</published>
    <updated>2018-09-14T16:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个不折腾会死星人，笔记软件也是我的折腾目标之一。</p><p>在此之前的纠结中我选择了为知笔记，为什么我不选择印象笔记呢？原因很简单，它对 Markdown 不支持，而我又是特别讨厌用富文本编辑器的。习惯上都是在笔记软件中写博文，然后写到差不多了粘贴到 Hexo 中然后发布。用印象笔记显然并不友好，虽然说我也可以直接在其中用 Markdown 语法写，但是那样代码块就没有办法高亮了。</p><a id="more"></a><p>除了这个原因，其实还有一个。就是 Mac 上印象笔记的 App 实在是太丑了.. 所以后面选择了为知笔记。但，为知笔记上写 Markdown 的话需要在笔记标题后面加上 .md 后缀，这让我很不爽。而且笔记的样式也太丑了吧，作为前端简直不能忍。</p><p>除了这两个家伙，我还尝试了其他的一些笔记应用，例如 Ulysses，Beer 之类的。虽然 Ulysses 看起来很好用，但无奈它变成了订阅制，感觉并不值得买了。之前的一次购买终身使用还差不多。Beer 的话就显得功能太过单薄了。这一类软件基本上都没有办法全平台通用，肯定没有印象笔记之类的那种手机 App。不过也还好，反正我不怎么在手机上记笔记，而且基本上也是电脑不离身的。</p><p>所以，跨不跨平台对我来说就没有什么所谓了。所以最后就聚焦到了一款叫 Quiver 的软件，同样的不是跨平台的应用。不过比较喜欢的是完美支持 Markdown 语法，而且还能够设置编辑器的快捷键，提供了简单的 Vim/Emacs 的模式。还有一点是特别喜欢的，就是可以自己自定义整个编辑器的样式，只要按照指定格式写一个 JSON 文件，就能够定制自己喜欢的界面了。大爱～</p><p><img src="https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/hldce.jpg" alt="Quiver"></p><p>当然，除了这些之外，还关心同步的问题。Quiver 没有提供数据同步功能，而是将笔记保存为 .qvlibrary 后缀的一个文件。So，只要把这个文件放到 iCloud 里面就相当于一个笔记同步的功能了。反正笔记也大不了那里去。5G 的 icloud 免费空间完全够用。</p><p>终于可以选定一个笔记软件一直用下去了。😬</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个不折腾会死星人，笔记软件也是我的折腾目标之一。&lt;/p&gt;
&lt;p&gt;在此之前的纠结中我选择了为知笔记，为什么我不选择印象笔记呢？原因很简单，它对 Markdown 不支持，而我又是特别讨厌用富文本编辑器的。习惯上都是在笔记软件中写博文，然后写到差不多了粘贴到 Hexo 中然后发布。用印象笔记显然并不友好，虽然说我也可以直接在其中用 Markdown 语法写，但是那样代码块就没有办法高亮了。&lt;/p&gt;
    
    </summary>
    
      <category term="折腾工具" scheme="http://www.ahonn.me/categories/tool/"/>
    
    
      <category term="Notes" scheme="http://www.ahonn.me/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>万恶的BOM：ï»¿ 与 \ufeff</title>
    <link href="http://www.ahonn.me/2017/07/24/the-evil-of-the-BOM-ufeff-and-i%C2%BB%C2%BF/"/>
    <id>http://www.ahonn.me/2017/07/24/the-evil-of-the-BOM-ufeff-and-i»¿/</id>
    <published>2017-07-24T14:14:22.000Z</published>
    <updated>2018-09-14T16:15:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞一个 Sass 文件的编译插件，主要使用 node-sass 来进行编译，在这过程中遇到一个蛮坑的小问题。</p><p>在不压缩的情况下使用 node-sass 进行编译的样式文件没有什么问题，可以正确的编译出该有的样式。可是当进行压缩时，就出了问题了。压缩后的文件莫名奇妙的在文件最开头多了几个奇怪的字符：<code>ï»¿</code>。</p><a id="more"></a><p>本着有什么不懂先 Google 的原则，搜索 <code>&quot;ï»¿&quot;</code>。发现 stack overflow 上有个相关的问题：<a href="https://stackoverflow.com/questions/3255993/how-do-i-remove-%C3%AF-from-the-beginning-of-a-file" target="_blank" rel="noopener">How do I remove ï»¿ from the beginning of a file?</a>。原来这是一个叫 BOM（Byte Order Mark）的东西，字节顺序标记，出现在文本文件头部，Unicode编码标准中用于标识文件是采用哪种格式的编码。</p><blockquote><p>在网页上使用BOM是个错误。BOM设计出来不是用来支持HTML和XML的。</p></blockquote><p>上面这句来自 <a href="https://www.zhihu.com/question/20167122/answer/14199022" target="_blank" rel="noopener">「带 BOM 的 UTF-8」和「无 BOM 的 UTF-8」有什么区别？网页代码一般使用哪个？</a> 的回答。我想补充一下，更可恶的事情是 BOM 在 CSS 中。</p><p>由于在文件开头多出了一个 BOM，使得压缩后的所有样式都失效了。一开始我尝试在文件最开头加上 <code>@charset &quot;utf-8&quot;</code>，但是并没有什么用。不过发现了在加上 <code>@charset &quot;utf-8&quot;</code> 后，变成了这样：</p><p><img src="https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/tnh93.jpg" alt="BOM"></p><p>多出来的一个小红点，鼠标移上去显示 <code>&quot;\ufeff&quot;</code>。找到罪魁祸首了，搜索 <code>&quot;\ufeff&quot;</code> 发现有篇关于 JavaScript 中处理 BOM 的文章：<a href="https://imququ.com/post/bom-and-javascript-trim.html" target="_blank" rel="noopener">BOM 和 JavaScript 中的 trim</a>。</p><p>最后得到解决方案，在编译后的样式中进行替换，移除 <code>\ufeff</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">css = css.replace(<span class="string">"\ufeff"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>虽然解决方案蛮简单的，但是在搜索答案与编码测试的过程中学到了蛮多。编码问题还是要注意的，虽然无法避免遇到 utf-8 with BOM，但是也应该尽量只保存为 utf-8 without BOM 编码格式。如果遇到奇怪的字符，那八成就是编码问题了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在搞一个 Sass 文件的编译插件，主要使用 node-sass 来进行编译，在这过程中遇到一个蛮坑的小问题。&lt;/p&gt;
&lt;p&gt;在不压缩的情况下使用 node-sass 进行编译的样式文件没有什么问题，可以正确的编译出该有的样式。可是当进行压缩时，就出了问题了。压缩后的文件莫名奇妙的在文件最开头多了几个奇怪的字符：&lt;code&gt;ï»¿&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://www.ahonn.me/categories/thinking/"/>
    
    
      <category term="前端" scheme="http://www.ahonn.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="CSS" scheme="http://www.ahonn.me/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Redux 源码解析</title>
    <link href="http://www.ahonn.me/2017/07/04/redux-source-code-insight/"/>
    <id>http://www.ahonn.me/2017/07/04/redux-source-code-insight/</id>
    <published>2017-07-04T09:44:24.000Z</published>
    <updated>2018-09-14T16:15:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><ul><li>单一数据源（store）</li><li>state 只可读（只能通过 Reducer 生成新 State）</li><li>使用纯函数执行修改（Reducer 必须为纯函数，无副作用）</li></ul><a id="more"></a><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><ul><li><code>dispatch</code> 触发 action 传递数据，但应该尽量减少传递的数据</li><li>如果有 middleware，在 action 发起之后，到达 reducer 之前执行</li><li>到达 reducer 之后，根据 action type 返回新 state</li></ul><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>Redux 提供的 API 主要有：</p><ul><li><code>createStore</code>: 创建 store 以及提供相关操作</li><li><code>combineReducers</code>: 合并不同的 reducer 函数</li><li><code>applyMiddleware</code>: 添加 Redux 中间件</li><li><code>bindActionCreators</code>: bind action 到组件中</li></ul><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p><code>createStore</code> 用来创建 Redux store，用于存放所有的 state。</p><p>通过 <code>const store = createStore(reducer, initialState)</code> 创建 store，只能通过 dispatch action 的方式来改变 state。同时提供了 <code>getState</code>，<code>subscribe</code> 等方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentReducer = reducer</span><br><span class="line">  <span class="keyword">let</span> currentState = preloadedState</span><br><span class="line">  <span class="keyword">let</span> currentListeners = []</span><br><span class="line">  <span class="keyword">let</span> nextListeners = currentListeners</span><br><span class="line">  <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: ActionTypes.INIT &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer,</span><br><span class="line">    [$$observable]: observable</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 <code>createStore</code> 方法时，<code>dispatch</code> 了名为 <code>@@redux/INIT</code> 的 action。表示已经初始化了 store。</p><p><code>dispatch</code> 方法的实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">true</span></span><br><span class="line">    currentState = currentReducer(currentState, action)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isDispatching = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> listeners = currentListeners = nextListeners</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> listener = listeners[i]</span><br><span class="line">    listener()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>currentState = currentReducer(currentState, action)</code> 执行 action 对应的 reducer 操作产生新的 state，如果有监听函数的话，按顺序触发监听函数。</p><p>监听函数由 <code>subscribe</code> 方法添加，<code>subscribe</code> 方法的返回一个 <code>unsubscribe</code> 函数，用来取消监听。</p><p><code>subscribe</code> 方法的具体实现:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isSubscribed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  ensureCanMutateNextListeners()</span><br><span class="line">  nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unsubscribe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isSubscribed) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isSubscribed = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners()</span><br><span class="line">    <span class="keyword">const</span> index = nextListeners.indexOf(listener)</span><br><span class="line">    nextListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上 <code>subscribe</code> 仅是在 <code>nextListeners</code> 中添加想要执行的监听函数，并返回了用于删除该函数的 <code>unsubscribe</code> 方法</p><h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h3><p><code>combineReducers</code> 用于合并不同的 reducer 函数，返回唯一的一个 reducer 函数供 <code>createStore</code> 使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="keyword">const</span> finalReducers = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = reducerKeys[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">'function'</span>) &#123;</span><br><span class="line">      finalReducers[key] = reducers[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">      <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasChanged ? nextState : state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先处理传入的 reducer 对象（包含不同的 reducer 函数），得到键值为 function 类型的对象 <code>finalReducers</code> 与一个包含其键的数组 <code>finalReducerKeys</code>。</p><p><code>combineReducers</code> 返回一个 <code>reducers</code> 函数用于处理 action，循环所有的 reducers 传入 action 进行处理，当 state 不变时，返回原来的 state</p><h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p><code>applyMiddleware</code> 的作用是添加中间件并执行中间件，主要是通过 <code>compose</code> 函数将所有的中间件串起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是 <code>funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</code> ，通过函数式编程中常见的 <code>f(g(args))</code> 形式串起来，返回一个函数，函数由内到外执行传入之前传入的函数数组，函数的参数将会传递到第一个执行的函数中。</p><p>简单的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'f1: '</span>+ a)</span><br><span class="line"><span class="keyword">return</span> a * <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'f2: '</span> + a)</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> funcs = [f1, f2]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class="line">func(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p><img src="https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/6vttf.jpg" alt="compose"></p><p>在 applyMiddleware 中 <code>dispatch = compose(...chain)(store.dispatch)</code>，即传入 compose 返回的函数的参数为 store 原来的 dispatch 函数。</p><p>也就是说，添加了中间件后，执行 dispatch 函数将会首先依次执行传入的中间件, 最后再执行原先的 <code>store.dispatch</code></p><p>关于 Redux midddleware 有篇文章写得很不错：<a href="https://github.com/asd0102433/blog/issues/1" target="_blank" rel="noopener">compose and middleware 源码分析</a></p><h3 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h3><p><code>bindActionCreators</code> 方法说白了就是把 action creators 转成拥有同名 keys 的对象，并使用 dispatch 将对象包裹起来，从而能够直接调用函数 dispatch action</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(actionCreator(...args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(actionCreators)</span><br><span class="line">  <span class="keyword">const</span> boundActionCreators = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">const</span> actionCreator = actionCreators[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分得源码很简单，只是简单的判断 actionCreators，是对象的话就返回一个键值为绑定了 dispatch 的函数的对象</p><h3 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h3><p>很久之前就学会了 Redux 的『使用』，但是却不明白到底是什么实现的，只知道应该那样使用。</p><p>阅读了源码之后对 Redux 整个流程更加清晰，有利于之后的使用。也更加理解 Redux 单向数据流的这种思想，虽然使用上更加繁琐，但是如果数据复杂起来，这种单向数据流的管理方式还是利大于弊的。</p><p><strong>参考链接</strong></p><ul><li><a href="http://cn.redux.js.org/index.html" target="_blank" rel="noopener">Redux 中文文档</a></li><li><a href="https://github.com/asd0102433/blog/issues/1" target="_blank" rel="noopener">compose and middleware 源码分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;三大原则&quot;&gt;&lt;a href=&quot;#三大原则&quot; class=&quot;headerlink&quot; title=&quot;三大原则&quot;&gt;&lt;/a&gt;三大原则&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;单一数据源（store）&lt;/li&gt;
&lt;li&gt;state 只可读（只能通过 Reducer 生成新 State）&lt;/li&gt;
&lt;li&gt;使用纯函数执行修改（Reducer 必须为纯函数，无副作用）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://www.ahonn.me/categories/thinking/"/>
    
    
      <category term="React" scheme="http://www.ahonn.me/tags/React/"/>
    
      <category term="Redux" scheme="http://www.ahonn.me/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>Vim 全局搜索插件：ctrlsf.vim</title>
    <link href="http://www.ahonn.me/2017/06/29/vim-plugin-ctrlsf/"/>
    <id>http://www.ahonn.me/2017/06/29/vim-plugin-ctrlsf/</id>
    <published>2017-06-29T10:05:46.000Z</published>
    <updated>2017-08-30T10:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>这两天一直在看文档看源码，Vim 上用的 Ack.vim 做全局搜索，但是用起来蛮难用的。</p><p>经过一番搜索，找到了国人写的全局搜索的插件：ctrlsf.vim，经过配置之后用了起来，感觉蛮好用的。</p><p>具体效果可以查看 <a href="https://github.com/dyng/ctrlsf.vim" target="_blank" rel="noopener">ctrlsf.vim</a></p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ctrlsf 是依赖 ack/ag/pt/rg 之类的，所有必须先安装其中之一。所以我们先安装 ack</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install ack</span><br></pre></td></tr></table></figure><p>其他系统安装方式查看：<a href="https://beyondgrep.com/install/" target="_blank" rel="noopener">https://beyondgrep.com/install/</a></p><p>然后安装 ctrlsf.vim 插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &apos;dyng/ctrlsf.vim&apos;</span><br></pre></td></tr></table></figure><p>运行 <code>:PlugInstall</code> 进行安装</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>我把 <code>Ctrl-f</code> 映射到了 <code>:CrtlSF&lt;Space&gt;</code>，这样就可以直接 <code>Ctrl-f</code> 然后直接输入、回车进行全局搜索了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;C-f&gt; :CtrlSF&lt;Space&gt;</span><br></pre></td></tr></table></figure><p>ctrlsf 插件还提供了两种模式：normal/compact。<br>normal 模式是左半屏为搜索结果，右半屏为预览窗口。而 compact 模式则是类似于 ctrlp 的 quickfix 窗口模式。<br>个人还是比较喜欢 quick 窗口模式，可以通过 <code>let g:ctrlsf_default_view_mode = &#39;compact&#39;</code> 设置为默认 compact 模式。</p><p>此外通过设置 <code>let g:ctrlsf_ignore_dir</code> 指定要搜索时忽略的目录。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>设置了快捷键映射之后就可以愉快的 <code>C-f</code> 输入回车搜索了。然后可以在搜索结果中移动，预览，打开。还能够按 M 更换显示模式。</p><p>具体可以查看：<a href="https://github.com/dyng/ctrlsf.vim#key-maps" target="_blank" rel="noopener">Key Maps</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天一直在看文档看源码，Vim 上用的 Ack.vim 做全局搜索，但是用起来蛮难用的。&lt;/p&gt;
&lt;p&gt;经过一番搜索，找到了国人写的全局搜索的插件：ctrlsf.vim，经过配置之后用了起来，感觉蛮好用的。&lt;/p&gt;
&lt;p&gt;具体效果可以查看 &lt;a href=&quot;https://github.com/dyng/ctrlsf.vim&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ctrlsf.vim&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="折腾工具" scheme="http://www.ahonn.me/categories/tool/"/>
    
    
      <category term="Vim" scheme="http://www.ahonn.me/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>到达杭州</title>
    <link href="http://www.ahonn.me/2017/06/23/arrived-in-hangzhou/"/>
    <id>http://www.ahonn.me/2017/06/23/arrived-in-hangzhou/</id>
    <published>2017-06-23T13:31:54.000Z</published>
    <updated>2017-08-30T10:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>折腾了好几天，终于到达杭州了。原本昨天就应该入职的，活生生得等到下周一。</p><p>一个人在外面最怕的就是找地方吃饭了。安排的酒店在宝龙城市广场附近，但是一个人实在是不想去商场里面吃那些东西。问了一下小伙伴的建议，跑去附近吃了个麻辣烫。</p><a id="more"></a><p>早上还跟婉清说公交卡门卡什么的记得检查好，晚上吃完饭就发现自己把房卡弄丢了。幸运的是，跑回去吃饭的地方找到了房卡，不然就很麻烦了。真是大头虾。</p><p>找房子的事情也是有点烦，看了很多租房的平台，感觉都略贵了一些。想上阿里内网看看的，可是却还没有入职看不了，只能作罢。等周一入职之后再说。</p><p>突然觉得酒店房间的桌椅的设计有问题。不知道为什么要把桌子下的高度设计得与椅子差不多高，这样我的脚应该如何是好啊。只能斜着坐了。更奇葩的是，桌面是类似镜面的那种，而桌子对着的天花板有两个灯。然后坐在这里就直接被桌子反射回来的灯光亮瞎。只好把这两个灯关掉了。</p><p>初到杭州，一切都好陌生。愿自己一切安好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;折腾了好几天，终于到达杭州了。原本昨天就应该入职的，活生生得等到下周一。&lt;/p&gt;
&lt;p&gt;一个人在外面最怕的就是找地方吃饭了。安排的酒店在宝龙城市广场附近，但是一个人实在是不想去商场里面吃那些东西。问了一下小伙伴的建议，跑去附近吃了个麻辣烫。&lt;/p&gt;
    
    </summary>
    
      <category term="生活小记" scheme="http://www.ahonn.me/categories/life/"/>
    
    
      <category term="碎碎念" scheme="http://www.ahonn.me/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>React 初始化渲染</title>
    <link href="http://www.ahonn.me/2017/06/08/write-a-react-from-scratch-init-render/"/>
    <id>http://www.ahonn.me/2017/06/08/write-a-react-from-scratch-init-render/</id>
    <published>2017-06-07T16:00:00.000Z</published>
    <updated>2018-09-14T15:54:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>该文章将阅读 React 初始化渲染相关的代码，并实现一个简单的将 JSX 渲染到页面的功能。（不包括组件生命周期与事件处理相关部分）</p><a id="more"></a><h2 id="源码解析：渲染过程"><a href="#源码解析：渲染过程" class="headerlink" title="源码解析：渲染过程"></a>源码解析：渲染过程</h2><h3 id="JSX-解析"><a href="#JSX-解析" class="headerlink" title="JSX 解析"></a>JSX 解析</h3><p>我们知道在 React 组件<code>render()</code> 返回的是 JSX，而 JSX 将会被 babel 转换。JSX 将被转换为 <code>React.createElement(type, config, children)</code>的形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="comment">// 转换前</span></span><br><span class="line">Class App extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;h1 id='title'&gt;Hello World&lt;h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 转换后</span><br><span class="line">var App = React.createClass(&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return React.createElement('h1', &#123;</span><br><span class="line">            id: 'title'</span><br><span class="line">        &#125;, 'hello world')</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>React.createElement()</code> 的实现位于 <a href="https://github.com/facebook/react/blob/15-stable/src/isomorphic/classic/element/ReactElement.js#L183" target="_blank" rel="noopener">/src/isomorphic/classic/element/ReactElement.js</a></p><p>这里的 <code>React.createElement()</code>是用来生成虚拟 DOM 元素，该函数对组件的属性，事件，子组件等进行了处理，并返回值为一个 <code>ReactElement</code> 对象（单纯的 JavaScript 对象，仅包括 type, props, key, ref 等属性）。</p><p>这恰好说明了 JSX 中的 <code>&lt;h1 id=&#39;title&#39;&gt;hello world&lt;/h1&gt;</code>实际上是 JavaScript 对象，而不是我们通常写的 HTML 标签。</p><h3 id="渲染到页面"><a href="#渲染到页面" class="headerlink" title="渲染到页面"></a>渲染到页面</h3><p>单单声明了组件而没有渲染到页面上我们是看不见的（废话），所以我们需要使用 <code>ReactDOM.render()</code>将其渲染到页面指定位置上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">'root'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.js'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><p><code>ReactDOM.render()</code> 的实现位于<a href="https://github.com/facebook/react/blob/master/src/renderers/dom/stack/client/ReactMount.js#L581" target="_blank" rel="noopener"> </a><a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/client/ReactMount.js" target="_blank" rel="noopener">/src/renderers/dom/client/ReactMount.js</a></p><p><code>ReactDOM.render()</code> 函数将会根据 <code>ReactElement</code> 的类型生成相对应的<code>ReactComponent</code> 实例，并调用其 <code>mountComponent()</code>函数进行组件加载（返回 HTML片段），递归加载所有组件后，通过 <a href="https://github.com/facebook/react/blob/b1768b5a48d1f82e4ef4150e0036c5f846d3758a/src/renderers/dom/shared/setInnerHTML.js" target="_blank" rel="noopener">setInnerHTML</a> 将 HTML 渲染到页面上。</p><p>判断需要生成那种 <code>ReactComponent</code>实例根据 <code>ReactElement</code> 对象的 type 属性来决定。对应 HTML 标签的 type 一般为字符串，而自定义的组件则是大写字母开头的组件函数（自定义组件需要 import，而 HTML 标签不需要）。</p><h4 id="生成-ReactComponent"><a href="#生成-ReactComponent" class="headerlink" title="生成 ReactComponent"></a>生成 <strong>ReactComponent</strong></h4><p>React 中生成对应的 <code>ReactComponent</code>实例由 <code>instantiateReactComponent()</code>完成，其实现位于 <a href="https://github.com/facebook/react/blob/15-stable/src/renderers/shared/stack/reconciler/instantiateReactComponent.js" target="_blank" rel="noopener">/src/renderers/shared/stack/reconciler/instantiateReactComponent.js</a></p><p><code>ReactComponent</code> 分为 3 种：</p><ul><li><p><code>ReactEmptyComponent</code>:  空组件（ReactElement 的 type 属性为 null 或 false 的组件），在浏览器中返回 <code>ReactDOMEmptyComponent</code>。</p></li><li><p><code>ReactHostComponent</code>: 原生组件（ReactElement 为string，number 或 ReactElement 的 type 属性为 string 的组件）。</p><ul><li><p><code>createInternalComponent()</code>：该函数用于创建原生组件，在浏览器中返回 <code>ReactDOMComponent</code>。</p></li><li><p><code>createInstanceForText()</code> : 该函数用于创建纯文本组件，在浏览器中返回 <code>ReactDOMTextComponent</code>。</p></li></ul></li><li><p><code>ReactCompositeComponent</code>: 自定义组件（ReactElement 的 type 属性为 function）</p></li></ul><p>可以发现 React 与平台解耦，使用 <code>ReactEmptyComponent</code> 与 <code>ReactHostComponent</code>。而这两种组件会根据平台的不同生成不同的组件对象，在浏览器中则为 <code>ReactDOMEmptyComponent</code>、<code>ReactDOMComponent</code> 与 <code>ReactDOMTextComponent</code>。</p><p>它们通过 <a href="https://github.com/facebook/react/blob/15-stable/src/renderers/dom/stack/client/ReactDOMStackInjection.js" target="_blank" rel="noopener">/src/renderers/dom/stack/client/ReactDOMStackInjection.js</a> 进行注入。</p><p>（ <a href="https://github.com/facebook/react/tree/15-stable/src/renderers" target="_blank" rel="noopener">/src/renderers </a>路径下包含各个平台上不同的 ReactComponent 实现，包括 react-art/react-dom/react-native。）</p><h2 id="从零开始：实现初始化渲染"><a href="#从零开始：实现初始化渲染" class="headerlink" title="从零开始：实现初始化渲染"></a>从零开始：实现初始化渲染</h2><h3 id="设置-babel"><a href="#设置-babel" class="headerlink" title="设置 babel"></a>设置 babel</h3><p>首先我们需要了解 babel 如何转换 JSX：<a href="https://babeljs.io/docs/plugins/transform-react-jsx/" target="_blank" rel="noopener">React JSX transform</a>。</p><p>babel 可以通过<code>transform-react-jsx</code>插件来设置解析 JSX 之后调用的函数，默认解析为调用 <code>React.createElement()</code>。所以这就是为什么虽然在 JSX 代码中没有使用到 React，却仍然需要导入它。</p><p>通过配置 <code>transform-react-jsx</code>插件的 <code>pragma</code>选项可以修改解析后调用的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改解析为调用 dom() 函数</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [<span class="string">"transform-react-jsx"</span>, &#123;</span><br><span class="line">      <span class="string">"pragma"</span>: <span class="string">"dom"</span> <span class="comment">// 默认 pragma 为 React.createElement</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>babel 将会把 JSX 中的标签名作为第一个参数，把 JSX 中的标签属性作为第二个参数，将标签内容作为剩余的参数。传递这些参数给 <code>pragma</code> 选项设置的函数。</p><p><strong>PS: 为了方便起见，我们使用默认的解析为 React.createElement()</strong></p><h3 id="实现-createElement"><a href="#实现-createElement" class="headerlink" title="实现 createElement"></a>实现 createElement</h3><p><code>createElement()</code>接受至少 2 个参数：元素类型 type（字符串表示原生元素，函数表示自定义元素），元素设置 config。其他参数视为元素的子元素 children。并且该函数返回的是一个 <code>ReactElement</code> 对象，属性包括 type, props, key, ref。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// element.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(type, props, key, ref) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type</span><br><span class="line">        <span class="keyword">this</span>.props = props</span><br><span class="line">        <span class="keyword">this</span>.key = key</span><br><span class="line">        <span class="keyword">this</span>.ref = ref</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, ...children</span>)｛</span></span><br><span class="line"><span class="function">    // ...</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">new</span> <span class="title">ReactElement</span>(<span class="params">type, props, key, ref</span>)</span></span><br><span class="line"><span class="function">｝</span></span><br></pre></td></tr></table></figure><p>然后需要导出 <code>createElement</code>，才能够通过 <code>React.createElement()</code> 的方式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createElement &#125; <span class="keyword">from</span> <span class="string">'./element'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> React = &#123;</span><br><span class="line">    createElement,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React</span><br></pre></td></tr></table></figure><p><code>ReactElement</code>需要 props, key 与 ref 参数，这三个参数将通过处理 config 与 children 得到。</p><p>我们将从 config 中获取 key 与 ref（若它们存在的话），并且根据 config 得到 props (去除一些不必要的属性)，同时将 children 添加到 props 当中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> props = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> key = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</span><br><span class="line">    ref = config.ref === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.ref</span><br><span class="line">    <span class="comment">// 当 key 为数字时，将 key 转换为字符串</span></span><br><span class="line">    key = config.key === <span class="literal">undefined</span> ? <span class="literal">null</span> : <span class="string">''</span> + config.key</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> propsName <span class="keyword">in</span> config) &#123;</span><br><span class="line">      <span class="comment">// 剔除一些不需要的属性（key, ref, __self, __source）</span></span><br><span class="line">      <span class="keyword">if</span> (RESERVED_PROPS.hasOwnProperty(propsName)) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (config.hasOwnProperty(propsName)) &#123;</span><br><span class="line">        props[propsName] = config[propsName]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    props.children = children</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ReactElement(type, props, key, ref)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，添加对 <code>defaultProps</code> 的支持。<code>defaultProps</code> 的使用方式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">App.defaultProps = &#123;</span><br><span class="line">    name: <span class="string">"ahonn"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当传入 App 组件的 props 中不包含 name 时，设置默认的 name 为 “ahonn”。具体实现：当 ReactElement 的 type 属性为组件函数且包含 defaultProps 时遍历 props，若 props 中不包含  defaultProps 中的属性时，设置默认的 props。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, ...children</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">        <span class="keyword">let</span> defaultProps = type.defaultProps</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> propsName <span class="keyword">in</span> defaultProps) &#123;</span><br><span class="line">            <span class="keyword">if</span> (props[propsName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                props[propsName] = defaultProps[propsName]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前为止完成了将 JSX 解析为函数调用（这部分由 babel 完成），调用 <code>React.createElement()</code> 生成 <code>ReactElement</code> 对象。</p><p>接下来将实现 <code>instantiateReactComponent()</code>，通过 ReactELemnt 生成相对应的 <code>ReactComponent</code> 实例。</p><h3 id="实现工厂方法-instantiateReactComponent"><a href="#实现工厂方法-instantiateReactComponent" class="headerlink" title="实现工厂方法 instantiateReactComponent"></a>实现工厂方法 instantiateReactComponent</h3><p><code>instantiateReactComponent(element)</code>接受一个参数 element，该参数可以是 ReactElement 对象，string，number，false 或者 null。</p><p>我们将只考虑 Web 端，而不像 React 一样使用适配器模式进行解耦。</p><p>ReactElement 生成相应 ReactComponent 实例的规则：</p><ul><li><p>element 为 null 或 false 时，生成 ReactDOMEmptyComponent 对象实例</p></li><li><p>element 为 string 或者 number 时，生成 ReactDOMTextComponent 对象实例</p></li><li><p>element 为 object</p><ul><li><p>element.type 为 string 时，生成 ReactDOMComponent 对象实例</p></li><li><p>element.type 为 function（组件函数）时，生成 ReactCompositeComponent 对象实例</p></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// virtual-dom.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">instantiateReactComponent</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (element === <span class="literal">null</span> || element === <span class="literal">false</span>) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> ReactDOMEmptyComponent()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">'string'</span> || <span class="keyword">typeof</span> element === <span class="string">'number'</span>) &#123;</span><br><span class="line">    instance = <span class="keyword">new</span> ReactDOMTextComponent(element)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> element === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> type = element.type</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'string'</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> ReactDomComponent(element)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'function'</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> ReactCompositeComponent(element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-ReactComponent"><a href="#实现-ReactComponent" class="headerlink" title="实现 ReactComponent"></a>实现 ReactComponent</h3><p>现在，我们需要有不同的 <code>ReactComponent</code> 类以供 <code>instantiateReactComponent()</code>使用。同时需要实现每个类的 <code>mountComponent()</code> 方法来返回对应的 HTML 片段。</p><p><strong>ReactDOMEmptyComponent</strong></p><p><code>ReactDOMEmptyComponent</code> 表示空组件， <code>mountComponent()</code> 方法返回空字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactDOMEmptyComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>._element = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mountComponent() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReactDOMTextComponent</strong></p><p>ReactDOMTextComponent 表示 DOM 文本组件，<code>mountComponent()</code>方法返回对应的字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactDOMTextComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(text) &#123;</span><br><span class="line">    <span class="keyword">this</span>._element = text</span><br><span class="line">    <span class="keyword">this</span>._stringText = <span class="string">''</span> + text</span><br><span class="line">    <span class="keyword">this</span>._rootID = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mountComponent(rootID) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rootID = rootID</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._stringText</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReactDOMComponent</strong></p><p>ReactDOMComponent 表示原生组件，即浏览器支持的标签（div, p, h1, etc.）。<code>mountConponent()</code> 方法返回对应的 HTML 字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactDomComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">let</span> tag = element.type</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._element = element</span><br><span class="line">    <span class="keyword">this</span>._tag = tag.toLowerCase()</span><br><span class="line">    <span class="keyword">this</span>._rootID = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mountComponent(rootID) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rootID = rootID</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._element.type !== <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'DOMComponent\'s Element.type must be string'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="string">`&lt;<span class="subst">$&#123;<span class="keyword">this</span>._tag&#125;</span> `</span></span><br><span class="line">    <span class="keyword">let</span> props = <span class="keyword">this</span>._element.props</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> propsName <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (propsName === <span class="string">'children'</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> propsValue = props[propsName]</span><br><span class="line">      ret += <span class="string">`<span class="subst">$&#123;propsName&#125;</span>=<span class="subst">$&#123;propsValue&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    ret += <span class="string">'&gt;'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tagContent = <span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> (props.children) &#123;</span><br><span class="line">      tagContent = <span class="keyword">this</span>._mountChildren(props.children)</span><br><span class="line">    &#125;</span><br><span class="line">    ret += tagContent</span><br><span class="line">    ret += <span class="string">`&lt;/<span class="subst">$&#123;<span class="keyword">this</span>._tag&#125;</span>&gt;`</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReactDOMComponent</code> 的 <code>mountComponent()</code>方法会相对复杂一点。具体实现思路是，通过 <code>ReactElement</code> 的 type 与 props 属性拼接对应的 HTML 标签。处理 props 的时候需要跳过 children 属性，因为需要将子组件放在当前组件中。</p><p>当存在子组件（children）时，调用 <code>_mountChildren(children)</code>将组件转换为对应的 HTML 片段。具体过程是遍历 children，转换为 <code>ReactComponent</code> 并调用其 <code>mountComponent()</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_mountChildren(children) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">in</span> children) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = children[index]</span><br><span class="line">    <span class="keyword">const</span> childrenComponent = instantiateReactComponent(child)</span><br><span class="line">    result += childrenComponent.mountComponent(index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReactCompositeComponent</strong></p><p>ReactCompositeComponent 表示自定义的组件，<code>mountComponent()</code>方法将根据提供的组件函数（element.type）实例化，并调用该组件的 <code>render()</code>方法返回 <code>ReactElement</code> 对象。再通过<code>instantiateReactComponent()</code> 生成对应的 <code>ReactComponent</code>，最后执行该 <code>ReactComponent</code> 的<code>mountComponent()</code>方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCompositeComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(element) &#123;</span><br><span class="line">    <span class="keyword">this</span>._element = element</span><br><span class="line">    <span class="keyword">this</span>._rootId = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mountComponent(rootID) &#123;</span><br><span class="line">    <span class="keyword">this</span>._rootId = rootID</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>._element.type !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'CompositeComponent\'s Element.type must be function'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Component = <span class="keyword">this</span>._element.type</span><br><span class="line">    <span class="keyword">const</span> props = <span class="keyword">this</span>._element.props</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> Component(props)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> renderedElement = instance.render()</span><br><span class="line">    <span class="keyword">const</span> renderedComponent = instantiateReactComponent(renderedElement)</span><br><span class="line">    <span class="keyword">const</span> renderedResult = renderedComponent.mountComponent(rootID)</span><br><span class="line">    <span class="keyword">return</span> renderedResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 ReactCompositeComponent 将之前的 ReactComponent 联系起来，并递归调用 <code>mountComponent</code>方法得到一段 HTML。最后 <code>render()</code>通过 node.innerHTML 将 HTML 字符串填到页面上对应的容器中。</p><h3 id="实现-render"><a href="#实现-render" class="headerlink" title="实现 render"></a>实现 render</h3><p>最后将之前的实现串起来，利用 innerHTML 将组件渲染到页面上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rootID = <span class="number">0</span></span><br><span class="line">  <span class="keyword">const</span> mainComponent = instantiateReactComponent(element)</span><br><span class="line">  <span class="keyword">const</span> containerContent = mainComponent.mountComponent(rootID)</span><br><span class="line"></span><br><span class="line">  container.innerHTML = containerContent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就基本上简单的实现了 React 中将组件渲染到页面上的部分。可以通过一个简单的例子验证一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'./tiny-react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'./tiny-react'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'))</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// App.js</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">import React, &#123; Component &#125; from './tiny-react'</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class App extends Component &#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;span&gt;It is Work!&lt;/span&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default App</span></span><br></pre></td></tr></table></figure><p>页面上将显示 It is Work!</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>虽然没有涉及到组件更新与组件生命周期，通过阅读 React 的源码基本上也对初始化渲染的过程有了一定的了解，希望对你有所帮助。</p><p>在此感谢 <a href="https://github.com/developit/preact" target="_blank" rel="noopener">preact</a>, <a href="https://github.com/Lucifier129/react-lite" target="_blank" rel="noopener">react-lite</a>, <a href="https://github.com/CodeFalling/react-tiny" target="_blank" rel="noopener">react-tiny</a> 等项目，它们为本文提供了很大帮助。</p><p>文中的所有代码均于 <a href="https://github.com/ahonn/tiny-react/tree/init-render" target="_blank" rel="noopener">tiny-react init-render</a> ，感谢阅读。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该文章将阅读 React 初始化渲染相关的代码，并实现一个简单的将 JSX 渲染到页面的功能。（不包括组件生命周期与事件处理相关部分）&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://www.ahonn.me/categories/thinking/"/>
    
    
      <category term="React" scheme="http://www.ahonn.me/tags/React/"/>
    
      <category term="从零开始" scheme="http://www.ahonn.me/tags/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>Koa2 源码分析</title>
    <link href="http://www.ahonn.me/2017/05/17/koa2-analysis/"/>
    <id>http://www.ahonn.me/2017/05/17/koa2-analysis/</id>
    <published>2017-05-16T16:00:00.000Z</published>
    <updated>2018-08-02T14:39:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p>Koa 的源码中主要为 <code>lib</code> 目录下的 <code>application.js</code>、<code>context.js</code>、<code>request.js</code> 与 <code>response.js</code> 文件</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── AUTHORS</span><br><span class="line">├── CODE_OF_CONDUCT.md</span><br><span class="line">├── History.md</span><br><span class="line">├── LICENSE</span><br><span class="line">├── Makefile</span><br><span class="line">├── Readme.md</span><br><span class="line">├── benchmarks</span><br><span class="line">├── docs</span><br><span class="line">├── lib</span><br><span class="line">│   ├── application.js</span><br><span class="line">│   ├── context.js</span><br><span class="line">│   ├── request.js</span><br><span class="line">│   └── response.js</span><br><span class="line">├── package.json</span><br><span class="line">└── test</span><br></pre></td></tr></table></figure><p><strong>application.js</strong>: 框架入口，导出 Application 类，即使用时导入的 Koa 类</p><p><strong>context.js</strong>: context 对象的原型，代理 request 与 response 对象</p><p><strong>request.js</strong>:  request 对象的原型，提供请求相关的数据与操作</p><p><strong>response.js</strong>: response 对象的原型，提供响应相关的数据与操作</p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>application.js 是 Koa 框架的入口，导出 Application 类来用于创建 app 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>); <span class="comment">// 导入 Koa, 即导入 Application 类</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa(); <span class="comment">// 创建 Application 类的实例</span></span><br></pre></td></tr></table></figure><p>Application 继承于 EventEmitter 类，使得 Koa 能够监听事件。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>Application 类包含了以下属性：</p><ul><li><strong>proxy</strong>: 是否信任 proxy header 参数，默认为 false</li><li><strong>middleware</strong>: 保存通过 <code>app.use(middleware)</code> 注册的中间件</li><li><strong>subdomainOffset</strong>: 子域默认偏移量，默认为 2</li><li><strong>env</strong>: 环境参数，默认为 NODE_ENV 或 ‘development’</li><li><strong>context</strong>: context 模块，通过 <code>context.js</code> 创建</li><li><strong>request</strong>: request 模块，通过 <code>request.js</code> 创建</li><li><strong>response</strong>: response 模块，通过 <code>response.js</code> 创建</li></ul><h2 id="Application-listen"><a href="#Application-listen" class="headerlink" title="Application#listen"></a>Application#listen</h2><p>Koa 通过 <code>app.listen(port)</code> 函数在某个端口启动服务。</p><p>listen 函数通过 http 模块开启服务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shorthand for:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    http.createServer(app.callback()).listen(...)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;Mixed&#125; ...</span></span><br><span class="line"><span class="comment"> * @return &#123;Server&#125;</span></span><br><span class="line"><span class="comment"> * @api public</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">listen(...args) &#123;</span><br><span class="line">  debug(<span class="string">'listen'</span>);</span><br><span class="line">  <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">  <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 <code>app.listen()</code>为 <code>http.createServer(app.callback()).listen(...)</code>的速记写法。</p><p><code>http.createServer()</code>用于创建 Web 服务器，接受一个请求监听函数，并在得到请求时执行。</p><p><code>app.callback()</code>用于处理请求，合并中间件与创建请求上下文对象等。</p><h3 id="Application-use"><a href="#Application-use" class="headerlink" title="Application#use"></a>Application#use</h3><p>Koa 通过 <code>app.use()</code>添加中间件，并将中间件储存在 <code>app.middleware</code>中。</p><p>在执行 <code>app.callback()</code>时会将 <code>app.middleware</code> 中的中间件合并为一个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use the given middleware `fn`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Old-style middleware will be converted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param &#123;Function&#125; fn</span></span><br><span class="line"><span class="comment"> * @return &#123;Application&#125; self</span></span><br><span class="line"><span class="comment"> * @api public</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">use(fn) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'middleware must be a function!'</span>);</span><br><span class="line">  <span class="keyword">if</span> (isGeneratorFunction(fn)) &#123;</span><br><span class="line">    deprecate(<span class="string">'Support for generators will be removed in v3. '</span> +</span><br><span class="line">              <span class="string">'See the documentation for examples of how to convert old middleware '</span> +</span><br><span class="line">              <span class="string">'https://github.com/koajs/koa/blob/master/docs/migration.md'</span>);</span><br><span class="line">    fn = convert(fn);</span><br><span class="line">  &#125;</span><br><span class="line">  debug(<span class="string">'use %s'</span>, fn._name || fn.name || <span class="string">'-'</span>);</span><br><span class="line">  <span class="keyword">this</span>.middleware.push(fn);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Koa1.x 版本使用 Generator Function 的方式写中间件，而 Koa2 改用 ES6 async/await。</p><p>所以在 <code>use()</code> 函数中会判断是否为旧风格的中间件写法，并对旧风格写法的中间件进行转换（使用 <a href="https://github.com/koajs/convert" target="_blank" rel="noopener">koa-convert</a> 进行转换）。</p><p>可以注意到这里 <code>use()</code> 函数返回了 this，这使得在添加中间件的时候能够链式调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app</span><br><span class="line">  .use(<span class="function"><span class="keyword">function</span> (<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do some thing</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .use(<span class="function"><span class="keyword">function</span> (<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do some thing</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="Application-callback"><a href="#Application-callback" class="headerlink" title="Application#callback"></a>Application#callback</h3><p><code>app.callback()</code>负责合并中间件，创建请求上下文对象以及返回请求处理函数等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a request handler callback</span></span><br><span class="line"><span class="comment"> * for node's native http server.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return &#123;Function&#125;</span></span><br><span class="line"><span class="comment"> * @api public</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">callback() &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.listeners(<span class="string">'error'</span>).length) <span class="keyword">this</span>.on(<span class="string">'error'</span>, <span class="keyword">this</span>.onerror);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    <span class="keyword">return</span> fn(ctx).then(handleResponse).catch(onerror);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> handleRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>compose</code> 函数（<a href="https://github.com/koajs/compose" target="_blank" rel="noopener">koa-compose</a>）合并 <code>app.middleware</code>中的所有中间件。<a href="/koa/compose.md">查看</a>关于 koa-compose 的分析。</p><p><code>app.callback()</code> 函数最后返回一个请求处理函数 <code>handleRequest</code>。该函数即为<code>http.createServer</code> 接收的请求处理函数，在得到请求时执行。</p><h4 id="handleRequest"><a href="#handleRequest" class="headerlink" title="handleRequest"></a>handleRequest</h4><p><code>handleRequest</code>函数首先将响应状态码默认设置为 404，接着通过 <code>app.createContext()</code>创建请求的上下文对象。</p><p><code>onFinished(res, onerror)</code>通过第三方库 <a href="https://github.com/jshttp/on-finished" target="_blank" rel="noopener">on-finished</a> 监听 http response，当请求结束时执行回调。</p><p>这里传入的回调是 <code>context.onerror(err)</code>，即当错误发生时才执行。</p><p>最后返回 <code>fn(ctx).then(handleResponse).catch(onerror)</code>，即将所有中间件执行（传入请求上下文对象 ctx），之后执行响应处理函数（<code>app.respond(ctx)</code>），当抛出异常时同样使用 <code>cintext.onerror(err)</code>处理。</p><h4 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h4><p>app.createContext() 用来创建请求上下文对象，并代理 Koa 的 request 和 response 模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize a new context.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @api private</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">createContext(req, res) &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.context);</span><br><span class="line">  <span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line">  <span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line">  context.app = request.app = response.app = <span class="keyword">this</span>;</span><br><span class="line">  context.req = request.req = response.req = req;</span><br><span class="line">  context.res = request.res = response.res = res;</span><br><span class="line">  request.ctx = response.ctx = context;</span><br><span class="line">  request.response = response;</span><br><span class="line">  response.request = request;</span><br><span class="line">  context.originalUrl = request.originalUrl = req.url;</span><br><span class="line">  context.cookies = <span class="keyword">new</span> Cookies(req, res, &#123;</span><br><span class="line">    keys: <span class="keyword">this</span>.keys,</span><br><span class="line">    secure: request.secure</span><br><span class="line">  &#125;);</span><br><span class="line">  request.ip = request.ips[<span class="number">0</span>] || req.socket.remoteAddress || <span class="string">''</span>;</span><br><span class="line">  context.accept = request.accept = accepts(req);</span><br><span class="line">  context.state = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对请求都对应在上下文对象中添加对应的 cookies。</p><h4 id="respond"><a href="#respond" class="headerlink" title="respond"></a>respond</h4><p><code>app.respond(ctx)</code> 函数，也就是 <code>app.createContext()</code>函数中的 <code>handleResponse</code>。在所有中间件执行完之后执行。</p><p>在 koa 中可以通过设置 <code>ctx.respond = false</code>来跳过这个函数，但不推荐这样做。另外，当上下文对象不可写时也会退出该函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span> === ctx.respond) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (!ctx.writable) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>当返回的状态码表示没有响应主体时，将响应主体置空：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ignore body</span></span><br><span class="line"><span class="keyword">if</span> (statuses.empty[code]) &#123;</span><br><span class="line">  <span class="comment">// strip headers</span></span><br><span class="line">  ctx.body = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> res.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求方法为 HEAD 时，判断响应头是否发送以及响应主体是否为 JSON 格式，若满足则设置响应 Content-Length：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'HEAD'</span> == ctx.method) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!res.headersSent &amp;&amp; isJSON(body)) &#123;</span><br><span class="line">    ctx.length = Buffer.byteLength(<span class="built_in">JSON</span>.stringify(body));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当返回的状态码表示有响应主体，但响应主体为空时，将响应主体设置为响应信息或状态码。并当响应头未发送时设置 Content-Type 与 Content-Length：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == body) &#123;</span><br><span class="line">  body = ctx.message || <span class="built_in">String</span>(code);</span><br><span class="line">  <span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">    ctx.type = <span class="string">'text'</span>;</span><br><span class="line">    ctx.length = Buffer.byteLength(body);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.end(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，对不同的响应主体进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// responses</span></span><br><span class="line"><span class="keyword">if</span> (Buffer.isBuffer(body)) <span class="keyword">return</span> res.end(body);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'string'</span> == <span class="keyword">typeof</span> body) <span class="keyword">return</span> res.end(body);</span><br><span class="line"><span class="keyword">if</span> (body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// body: json</span></span><br><span class="line">body = <span class="built_in">JSON</span>.stringify(body);</span><br><span class="line"><span class="keyword">if</span> (!res.headersSent) &#123;</span><br><span class="line">  ctx.length = Buffer.byteLength(body);</span><br><span class="line">&#125;</span><br><span class="line">res.end(body);</span><br></pre></td></tr></table></figure><h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h2><p>在 application.js 中，<code>callback()</code>函数通过 <code>koa-compose</code> 组合所有的中间件，组合成单个函数。</p><p>koa-compose  的实现很简单：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(middleware)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware stack must be an array!'</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Middleware must be composed of functions!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'next() called multiple times'</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> dispatch(i + <span class="number">1</span>)</span><br><span class="line">        &#125;))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断了传入得中间件参数是否为数组，并检查且数组的元素是否为函数，然后返回了一个将中间件组合起来的函数。</p><p>重点关注返回的函数中的<code>dispatch(i)</code>函数，这个函数将获取第一个中间件，并在返回的 Promise 中执行。当中间件<code>await next()</code>时执行下一个中间件，即 <code>dispatch(i + 1)</code>。</p><p>执行流程可以简单看作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">middleware1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware1 begin'</span>);</span><br><span class="line">    <span class="keyword">await</span> middleware2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">middleware2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware2 begin'</span>);</span><br><span class="line">    <span class="keyword">await</span> middleware3();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware2 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">middleware3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware3 begin'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'middleware3 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">middleware1();</span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line">middleware1 begin</span><br><span class="line">middleware2 begin</span><br><span class="line">middleware3 begin</span><br><span class="line">middleware3 end</span><br><span class="line">middleware2 end</span><br><span class="line">middleware1 end</span><br></pre></td></tr></table></figure><p><code>compose()</code> 函数通过 Promise 将这个过程串联起来，从而返回单个中间件函数。</p><h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Koa 中的 Context 模块封装了 request 与 response，代理了这两个对象的方法与属性。</p><p>其中使用了 Tj 写的 <a href="https://github.com/tj/node-delegates" target="_blank" rel="noopener">node-delegates</a> 库，用于代理 context.request 与 context.response 上的方法与属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Response delegation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">delegate(proto, <span class="string">'response'</span>)</span><br><span class="line">  .method(<span class="string">'attachment'</span>)</span><br><span class="line">  .method(<span class="string">'redirect'</span>)</span><br><span class="line">  .method(<span class="string">'remove'</span>)</span><br><span class="line">  .method(<span class="string">'vary'</span>)</span><br><span class="line">  .method(<span class="string">'set'</span>)</span><br><span class="line">  .method(<span class="string">'append'</span>)</span><br><span class="line">  .method(<span class="string">'flushHeaders'</span>)</span><br><span class="line">  .access(<span class="string">'status'</span>)</span><br><span class="line">  .access(<span class="string">'message'</span>)</span><br><span class="line">  .access(<span class="string">'body'</span>)</span><br><span class="line">  .access(<span class="string">'length'</span>)</span><br><span class="line">  .access(<span class="string">'type'</span>)</span><br><span class="line">  .access(<span class="string">'lastModified'</span>)</span><br><span class="line">  .access(<span class="string">'etag'</span>)</span><br><span class="line">  .getter(<span class="string">'headerSent'</span>)</span><br><span class="line">  .getter(<span class="string">'writable'</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>context 除了代理这两个模块之外，还包含了一个请求异常时的错误处理函数。</p><p>在 application.js 的 <code>callback()</code>使用到这个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line"><span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">onFinished(res, onerror);</span><br><span class="line"><span class="keyword">return</span> fn(ctx).then(handleResponse).catch(onerror);</span><br></pre></td></tr></table></figure><h3 id="Context-onerror"><a href="#Context-onerror" class="headerlink" title="Context#onerror"></a>Context#onerror</h3><p><code>context.onerror(err)</code>首先对传入的 err 变量进行判断，当 err 为空时退出该函数，或者当 err 不为空且不为 Error 类型时抛出异常。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">null</span> == err) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(err <span class="keyword">instanceof</span> <span class="built_in">Error</span>)) err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`non-error thrown: <span class="subst">$&#123;err&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>接着触发 app 自身的 error 事件，将错误抛给 app。</p><p>在此之前，设置 <code>headerSent</code>变量表示响应头是否发送，若响应头以发送，或者不可写（即无法在响应中添加错误信息等），则退出该函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> headerSent = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.headerSent || !<span class="keyword">this</span>.writable) &#123;</span><br><span class="line">  headerSent = err.headerSent = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate</span></span><br><span class="line"><span class="keyword">this</span>.app.emit(<span class="string">'error'</span>, err, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// nothing we can do here other</span></span><br><span class="line"><span class="comment">// than delegate to the app-level</span></span><br><span class="line"><span class="comment">// handler and log.</span></span><br><span class="line"><span class="keyword">if</span> (headerSent) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为发生了错误，所以必须将之前的中间设置的响应头信息清空。</p><p>这里使用了 Node 提供的 <a href="https://nodejs.org/api/http.html#http_class_http_serverresponse" target="_blank" rel="noopener">http.ServerResponse</a> 类上的 <code>getHeaderNames()</code> 与 <code>removeHeader()</code> 方法。但<code>getHeaderNames()</code></p><p>这个函数是在 Node.js 7.7 时加入的，所以当没有提供该方法时需要使用 <code>_header</code>来清空响应头。详情可见: <a href="https://github.com/nodejs/node/pull/10805" target="_blank" rel="noopener">Node.js #10805。</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first unset all headers</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> res.getHeaderNames === <span class="string">'function'</span>) &#123;</span><br><span class="line">  res.getHeaderNames().forEach(<span class="function"><span class="params">name</span> =&gt;</span> res.removeHeader(name));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  res._headers = &#123;&#125;; <span class="comment">// Node &lt; 7.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空之前的中间件设置的响应头之后，将响应头设置为 <code>err.headers</code>，并设置 Context-Type 与状态码。</p><p>当错误码为 ENOENT 时，意味着找不到该资源，将状态码设置为 404；当没有状态码或状体啊码错误时默认设置为 500。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then set those specified</span></span><br><span class="line"><span class="keyword">this</span>.set(err.headers);</span><br><span class="line"></span><br><span class="line"><span class="comment">// force text/plain</span></span><br><span class="line"><span class="keyword">this</span>.type = <span class="string">'text'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ENOENT support</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'ENOENT'</span> == err.code) err.status = <span class="number">404</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// default to 500</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'number'</span> != <span class="keyword">typeof</span> err.status || !statuses[err.status]) err.status = <span class="number">500</span>;</span><br></pre></td></tr></table></figure><p>最后当抛出的错误为自定义错误时，返回错误信息。</p><p>Koa 使用 <a href="https://github.com/jshttp/http-errors" target="_blank" rel="noopener">http-errors</a> 创建错误对象，<code>expose</code> 属性表示是否像客户端暴露错误信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = statuses[err.status];</span><br><span class="line"><span class="keyword">const</span> msg = err.expose ? err.message : code;</span><br><span class="line"><span class="keyword">this</span>.status = err.status;</span><br><span class="line"><span class="keyword">this</span>.length = Buffer.byteLength(msg);</span><br><span class="line"><span class="keyword">this</span>.res.end(msg);</span><br></pre></td></tr></table></figure><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>Request 模块封装了请求相关的属性以及方法。通过 application 中的 <code>createContext()</code> 方法，代理对应的 request 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = context.request = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.request);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">context.req = request.req = response.req = req;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">request.response = response;</span><br></pre></td></tr></table></figure><p><code>request.req</code>为原生的请求对象，在 Request 模块中属性的获取都是通过 <code>ths.req</code> 来获取的（即 <code>request.req</code>）。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>Response 模块封装了响应相关的属性以及方法。与 request 相同，通过<code>createContext()</code> 方法代理对应的 response 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = context.response = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.response);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">context.res = request.res = response.res = res;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">response.request = request;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;源码结构&quot;&gt;&lt;a href=&quot;#源码结构&quot; class=&quot;headerlink&quot; title=&quot;源码结构&quot;&gt;&lt;/a&gt;源码结构&lt;/h2&gt;&lt;p&gt;Koa 的源码中主要为 &lt;code&gt;lib&lt;/code&gt; 目录下的 &lt;code&gt;application.js&lt;/code&gt;、&lt;code&gt;context.js&lt;/code&gt;、&lt;code&gt;request.js&lt;/code&gt; 与 &lt;code&gt;response.js&lt;/code&gt; 文件&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://www.ahonn.me/categories/thinking/"/>
    
    
      <category term="Koa" scheme="http://www.ahonn.me/tags/Koa/"/>
    
      <category term="Node.js" scheme="http://www.ahonn.me/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>转投 Neovim</title>
    <link href="http://www.ahonn.me/2017/03/27/use-neovim/"/>
    <id>http://www.ahonn.me/2017/03/27/use-neovim/</id>
    <published>2017-03-27T03:10:06.000Z</published>
    <updated>2018-08-02T14:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前就听说过 Neovim，但一直没有怎么了解过。昨天下午折腾了一下，彻底转投 Neovim 了。</p><p>虽然说这两货的差别目前还不是很大，但是 Neovim 实现了嵌入式终端模拟器，Excited! 各种 REPL 插件统统都可以卸载了！</p><a id="more"></a><h2 id="迁移配置文件"><a href="#迁移配置文件" class="headerlink" title="迁移配置文件"></a>迁移配置文件</h2><p>Neovim 配置完全兼容原来的 <code>.vimrc</code>，只需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$&#123;XDG_CONFIG_HOME:=$HOME/.config&#125;</span></span><br><span class="line">ln -s ~/.vim <span class="variable">$XDG_CONFIG_HOME</span>/nvim</span><br><span class="line">ln -s ~/.vimrc <span class="variable">$XDG_CONFIG_HOME</span>/nvim/init.vim</span><br></pre></td></tr></table></figure><h2 id="使用-ale-代替-syntastic"><a href="#使用-ale-代替-syntastic" class="headerlink" title="使用 ale 代替 syntastic"></a>使用 ale 代替 syntastic</h2><p>老早就觉得 <code>syntastic</code> 同步检查代码好难用，这下换成 <code>ale</code> 舒服多了。有之前使用 atom 时自带的代码检查的感觉。</p><p>(Vim 8 好像也已经提供了异步 API，但是我等到换成 Neovim 才知道..)</p><h2 id="把-Leader-改成空格"><a href="#把-Leader-改成空格" class="headerlink" title="把 Leader 改成空格"></a>把 Leader 改成空格</h2><p>其实是看了 <a href="https://zhuanlan.zhihu.com/p/25905625" target="_blank" rel="noopener">Vim 高效率配置导论</a> 这篇文章之后试着改的，改完发现空格比起原先的 <code>,</code> 好用多了。让大拇指动了起来。</p><p>然后切换 buffter 的快捷键就映射成了 <code>&lt;Space&gt; + n/m</code>，简直不要太顺手。</p><h2 id="使用-Spacegray-主题"><a href="#使用-Spacegray-主题" class="headerlink" title="使用 Spacegray 主题"></a>使用 Spacegray 主题</h2><p>之前使用的 <code>molokai</code> 看久了有点视觉疲劳，发现之前在用 <code>sublime text</code> 时使用的 <code>Spacegray</code> 也有 Vim 版本，果断换之。（折腾高亮主题是永恒的.. ）</p><h2 id="优化难用的缩进调整"><a href="#优化难用的缩进调整" class="headerlink" title="优化难用的缩进调整"></a>优化难用的缩进调整</h2><p>在 Visual 模式下调整缩进很不好用，<code>v&gt;</code> 之后又得重新选中，虽然说可以 <code>v3&gt;</code> 之类的，但是需要去计算多少个缩进，看起来并不是很明显。</p><p>遂，添加了下面这两个 mapping：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vnoremap &lt; &lt;v</span><br><span class="line">vnoremap &gt; &gt;v</span><br></pre></td></tr></table></figure><p>这样映射之后我就可以 <code>v&gt;&gt;&gt;</code> 去缩进了，好用到不行！</p><h2 id="Vim-使用总结"><a href="#Vim-使用总结" class="headerlink" title="Vim 使用总结"></a>Vim 使用总结</h2><p>使用 Vim 也差不多一个来月了，越来越发现 Vim 的便利之处，虽然说折腾配置插件花的时间会久一点。但是折腾完之后效率提高还是蛮多的，以至于现在在别的编辑器里下意识的用 Vim 模式，发现没有之后用方向键或者鼠标去移动都觉得超级慢。</p><p>开始理解 Vim 学习路线那张图表的意思了～</p><blockquote><p>我的 Vim 配置：<a href="https://github.com/ahonn/vimrc" target="_blank" rel="noopener">vimrc</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前就听说过 Neovim，但一直没有怎么了解过。昨天下午折腾了一下，彻底转投 Neovim 了。&lt;/p&gt;
&lt;p&gt;虽然说这两货的差别目前还不是很大，但是 Neovim 实现了嵌入式终端模拟器，Excited! 各种 REPL 插件统统都可以卸载了！&lt;/p&gt;
    
    </summary>
    
      <category term="折腾工具" scheme="http://www.ahonn.me/categories/tool/"/>
    
    
      <category term="Vim" scheme="http://www.ahonn.me/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴暑假实习面试总结</title>
    <link href="http://www.ahonn.me/2017/03/16/alibaba-summer-internship-interview-summary/"/>
    <id>http://www.ahonn.me/2017/03/16/alibaba-summer-internship-interview-summary/</id>
    <published>2017-03-16T07:15:24.000Z</published>
    <updated>2018-08-02T14:37:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>2月末的时候，通过 <a href="https://simplyy.space/" target="_blank" rel="noopener">simplyY</a> 内推了阿里巴巴暑期实习的前端开发岗，在此表示感谢。<br>接着3月1号收到了内推的通知邮件，完善信息后很快就接到了一面的电话（3月3号）。</p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>面试了大概20分钟左右，整体内容还是比较偏基础。一开始是正常流程的自我介绍，说是三分钟自我介绍，但是我语速比较快的不到两分钟的介绍完了。(刚好是临近中午，原本打算吃饭的，要是去吃饭的话就得在路上面了…）</p><h3 id="CSS-垂直居中"><a href="#CSS-垂直居中" class="headerlink" title="CSS 垂直居中"></a>CSS 垂直居中</h3><p>这个写过一篇博文专门总结过，不过面试的时候还是太过紧张没有答全。主要是 Flexbox 布局的垂直居中比较容易忘记。</p><p>具体就不再啰嗦了，详情可以查看：<a href="http://www.ahonn.me/2016/06/29/vertical-center-for-css/">CSS 实现垂直居中</a></p><a id="more"></a><h3 id="call-与-apply-的区别，以及性能差别"><a href="#call-与-apply-的区别，以及性能差别" class="headerlink" title="call 与 apply 的区别，以及性能差别"></a>call 与 apply 的区别，以及性能差别</h3><p><code>call</code> 与 <code>apply</code> 的区别，这是一个老生常谈的面试题了。<code>call()</code> 与 <code>apply()</code> 都是用于在指定 this 值与参数的情况下调用函数，主要的区别在于除了传入 this 值之外，<code>apply()</code> 接收类数组或者类数组对象来作为调用的函数的参数，而 <code>call()</code> 则是需要分别传入函数的每一个参数（除第一个参数之外的其他参数）。</p><blockquote><p>call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。—— 『JavaScript 高级程序设计』</p></blockquote><p>区别的话基本上只要看过书或者刷过面试题都会知道，但 <code>call()</code> 与 <code>apply()</code> 之间的性能差别就不是那么常见了。<br>比较幸运的是，之前在阅读 underscore 源码的时候有注意到这个细节，为此也写过另外的文章：<a href="http://www.ahonn.me/2016/05/03/starting-from-the-optimizeCb/">从 optimizeCb 说起</a>。</p><p>实践证明，在知道调用函数的参数数量时，使用 <code>call()</code> 的性能会优于 <code>apply()</code>。主要在实现的过程中 <code>apply()</code> 需要完成额外的操作（判断第二个参数类数组的长度，etc.）。具体为什么有这种差别，可以在 ECMAScript Language Specification 中查看 <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.3" target="_blank" rel="noopener">Function.prototype.apply</a> 与 <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.4" target="_blank" rel="noopener">Function.prototype.call</a> 的具体实现差异。</p><p><strong>参考链接</strong></p><ul><li><a href="http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply" target="_blank" rel="noopener">javascript - What is the difference between call and apply? - Stack Overflow</a></li><li><a href="http://stackoverflow.com/questions/23769556/why-is-call-so-much-faster-than-apply" target="_blank" rel="noopener">javascript - Why is call so much faster than apply? - Stack Overflow</a></li><li><a href="https://jsperf.com/call-apply-segu" target="_blank" rel="noopener">call vs apply · jsPerf</a></li></ul><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>又是一个老生常谈的问题。我的理解比较肤浅，就是 A 函数返回 B 函数，B 函数能够访问 A 函数中的局部变量，使得在 A 外部的作用域中能够使用 B 函数间接操作 A 函数中的局部变量，这样就形成了一个闭包。A 函数中的局部变量与返回的 B 函数一同存在，不会被垃圾回收机制清理（引用还存在）。</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。—— 维基百科</p></blockquote><p>建议阅读 <a href="https://book.douban.com/subject/26351021/" target="_blank" rel="noopener">『你不知道的 JavaScript（上卷）』</a> 中有关作用域与闭包的部分。</p><h3 id="什么是尾递归"><a href="#什么是尾递归" class="headerlink" title="什么是尾递归"></a>什么是尾递归</h3><blockquote><p>在计算机科学里，尾调用是指一个函数里的最后一个动作是一个函数调用的情形：即这个调用的返回值直接被当前函数返回的情形。这种情形下称该调用位置为尾位置。若这个函数在尾位置调用本身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，是递归的一种特殊情形。—— 维基百科</p></blockquote><p>一般递归实现阶乘：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般递归需要中栈上维护函数的调用信息直到函数返回后才释放，容易发生『栈溢出』错误。但对于尾递归来说，只需要维护一个调用记录。</p><p>尾递归实现阶乘：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fact-iter(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>-<span class="title">iter</span>(<span class="params">n, a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fact-iter(n - <span class="number">1</span>, n * a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于递归与尾递归，在 <a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">『计算机程序的构造和解释』</a>中也有类似的讨论。</p><h3 id="React-的设计理念"><a href="#React-的设计理念" class="headerlink" title="React 的设计理念"></a>React 的设计理念</h3><p>这部分答得不是很好，只提到了组件化，单向数据流，Virtual DOM 之类的。</p><p>有关 React 的设计思想可以参考这一篇文章：<a href="https://github.com/react-guide/react-basic" target="_blank" rel="noopener">React 设计思想</a>。</p><h3 id="前端安全（攻击方式与如何防范）"><a href="#前端安全（攻击方式与如何防范）" class="headerlink" title="前端安全（攻击方式与如何防范）"></a>前端安全（攻击方式与如何防范）</h3><p>第一反应就是 <code>XSS</code> 与 <code>CSRF</code>，<code>XSS</code> 可以通过对输入数据进行转义来防范，而 <code>CSRF</code> 则通过使用 SSL 链接访问资源或者请求中添加验证码来进行防范。</p><p>除此之外我漏掉了网络劫持，控制台注入代码等攻击方式，这里有篇文章做了详细介绍：<a href="https://segmentfault.com/a/1190000006672214" target="_blank" rel="noopener">聊一聊WEB前端安全那些事儿</a>。</p><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><p>第一次远程视频面试，好紧张。</p><p>一开始问了 CSS 中 position 属性的 absolute 的作用以及应用场景，这个基本上没有什么问题。接着叫我拿纸写冒泡排序（手写 T-T），飞快的写完。<br>然后跟一面一样也问了前端安全相关的问题，一下子都不紧张了.. 没有想象中的难。</p><h3 id="实现-bind-函数"><a href="#实现-bind-函数" class="headerlink" title="实现 bind 函数"></a>实现 bind 函数</h3><p>同样是让我写代码，同样是手写（T-T）。这个问题对我来说不算难，不过只是写了简单的实现，没有考虑其他情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本原理就是使用 <code>apply()</code> 与闭包，返回包含 <code>apply()</code> 的闭包使得 <code>apply()</code> 绑定指定作用域，但并未执行。</p><h3 id="阅读-Underscore-源码的经历"><a href="#阅读-Underscore-源码的经历" class="headerlink" title="阅读 Underscore 源码的经历"></a>阅读 Underscore 源码的经历</h3><p>之前拖拖拉拉的阅读完了 Underscore 的源码，并提交了一个小 <a href="https://github.com/jashkenas/underscore/pull/2630" target="_blank" rel="noopener">Pull Request</a>。</p><p>在阅读的过程中学到了许多的东西，例如上面提到的 call 与 apply 的性能差别，除此之外还有如何去判断变量的类型，以及如何判断两个变量是否相等，等等。另外也了解到许多闭包的使用场景。</p><h3 id="阅读其他类库的收获"><a href="#阅读其他类库的收获" class="headerlink" title="阅读其他类库的收获"></a>阅读其他类库的收获</h3><p>除了 Underscore 之外还阅读过一点 Bootstrap 和 jQuery，这个博客主题的样式部分的组织方式就是参考了 Bootstrap 的组织方式，另外也稍微阅读过 jQuery中 <code>$.ajax</code> 以及事件相关的源码。</p><p>在阅读代码的过程中的收获就是学习了一些组织代码的方式，还有如何写才能有利于拓展，更加健壮。其中也学到了一些提高性能的技巧，函数缓存，事件队列之类的。</p><h3 id="博客主题的开发经历"><a href="#博客主题的开发经历" class="headerlink" title="博客主题的开发经历"></a>博客主题的开发经历</h3><p>其实一开始写主题只是想给自己用，之后发现蛮多人也喜欢我这个主题的，并时不时有人中 Github 上提 Issue，这对我是莫大的鼓励。虽然我水平并不是很高，但是写出来的东西有人用感觉真的是特别开心，也特别有动力去改进。</p><p>从开始去写主题到现在差不多也一年了，这一年中我从前端小白变成前端大白。在维护的过程中学习到很多东西，虽然目前写得也不是很好，但是我还是会慢慢改进继续维护下去的。</p><p>维护的过程中的收获就是，当站在自己的角度看问题与在别人的角度看完全是不一样的，或许有个功能我并不需要，但是有人提了，我就得站在『用户』的角度去思考，去实现。『用户』只关心能不能用，好不好用，而并不关心代码写得怎么样。</p><h3 id="实习期间遇到得难题"><a href="#实习期间遇到得难题" class="headerlink" title="实习期间遇到得难题"></a>实习期间遇到得难题</h3><p>可能我做的工作相对简单，就算不会，基本上靠搜索引擎都能够解决。<strong>我觉得能用 Google 解决的问题不算难题。</strong>以我现在的水平，还达不到遇到的难题 Google 搜索不到的😹</p><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>三面基本上没有问太过具体的前端相关的问题，大部分是在聊聊看法，聊聊项目。</p><p>开始让我用纸画出博客的设计，其实主要还是主题，没什么难度，毕竟代码都是我自己写的。</p><p>然后让我介绍一下我熟悉的一个框架，说的 React，提及到了 Vitrual DOM 和 diff 算法，说了一下 diff 算法的大概策略。还有说到组件化，单向数据流等等。幸运的是，我在二面之前刷了 『深入 React 技术栈』这本书，结合之前的实践能够说个大概。</p><p>中间有聊到兴趣爱好，我想了想好像只有写代码。听歌应该也算？写代码的时候必定要听歌。我记得去年国庆有一天从起床写到晚上睡觉，差不多写了 11 个小时，那时候正在折腾 React 与 Meteor。我自己都觉得不可思议。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能是运气问题，我觉得我的这几面难度都不高😹。得益于看的书，好多知识点都是书上有的。基本上基础的前端面试题都可以在红宝书上找到，真不愧为前端面试宝典。另外 Github 上的这个博客主题也帮了很大的忙，300+ star 果然还是有点用处的（虽然说 star 不能代表什么，而且的确写得也很水，但作用不可否认）。</p><p>最后，基础很重要，基础扎实是基本。但是如果想要有突出的表现还是需要更有深度的研究。需要经常思考总结，不仅仅是浮于表面，更要深入原理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2月末的时候，通过 &lt;a href=&quot;https://simplyy.space/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;simplyY&lt;/a&gt; 内推了阿里巴巴暑期实习的前端开发岗，在此表示感谢。&lt;br&gt;接着3月1号收到了内推的通知邮件，完善信息后很快就接到了一面的电话（3月3号）。&lt;/p&gt;
&lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;p&gt;面试了大概20分钟左右，整体内容还是比较偏基础。一开始是正常流程的自我介绍，说是三分钟自我介绍，但是我语速比较快的不到两分钟的介绍完了。(刚好是临近中午，原本打算吃饭的，要是去吃饭的话就得在路上面了…）&lt;/p&gt;
&lt;h3 id=&quot;CSS-垂直居中&quot;&gt;&lt;a href=&quot;#CSS-垂直居中&quot; class=&quot;headerlink&quot; title=&quot;CSS 垂直居中&quot;&gt;&lt;/a&gt;CSS 垂直居中&lt;/h3&gt;&lt;p&gt;这个写过一篇博文专门总结过，不过面试的时候还是太过紧张没有答全。主要是 Flexbox 布局的垂直居中比较容易忘记。&lt;/p&gt;
&lt;p&gt;具体就不再啰嗦了，详情可以查看：&lt;a href=&quot;http://www.ahonn.me/2016/06/29/vertical-center-for-css/&quot;&gt;CSS 实现垂直居中&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://www.ahonn.me/categories/thinking/"/>
    
    
      <category term="前端" scheme="http://www.ahonn.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://www.ahonn.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="实习" scheme="http://www.ahonn.me/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>答前端面试题</title>
    <link href="http://www.ahonn.me/2017/03/11/answer-front-end-questions/"/>
    <id>http://www.ahonn.me/2017/03/11/answer-front-end-questions/</id>
    <published>2017-03-11T09:13:46.000Z</published>
    <updated>2018-09-14T16:16:41.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>答 <a href="https://zhuanlan.zhihu.com/p/25701897" target="_blank" rel="noopener">中级前端工程师面试 我想问的几个问题</a> 中的几个问题，感谢 <a href="https://www.zhihu.com/people/simplyy/answers" target="_blank" rel="noopener">@SimplyY</a></p></blockquote><h2 id="我最大的优势以及为什么选择前端"><a href="#我最大的优势以及为什么选择前端" class="headerlink" title="我最大的优势以及为什么选择前端"></a>我最大的优势以及为什么选择前端</h2><ul><li>我最大的优势是自学能力与理解能力强，并且不给自己套上『我是前端程序员』的枷锁，对于所有技术保持好奇心，不畏惧舒适圈外的事物并敢于尝试。</li><li>选择前端的理由是，前端能够迅速的把想法实现，可选技术栈广泛（Web，移动端，桌面客户端），也是前端的优点之一。</li></ul><a id="more"></a><h2 id="前后端分离的原理及意义"><a href="#前后端分离的原理及意义" class="headerlink" title="前后端分离的原理及意义"></a>前后端分离的原理及意义</h2><p>后端提供数据接口，前端获取数据并呈现。</p><h3 id="前后端分离的意义"><a href="#前后端分离的意义" class="headerlink" title="前后端分离的意义"></a>前后端分离的意义</h3><ul><li>后端无须套模版，前后端解耦。</li><li>提高工作效率，前后端同步开发。</li></ul><h2 id="对-react-的理解与相对于-jQuery-开发的优势"><a href="#对-react-的理解与相对于-jQuery-开发的优势" class="headerlink" title="对 react 的理解与相对于 jQuery 开发的优势"></a>对 react 的理解与相对于 jQuery 开发的优势</h2><h3 id="对-React-的理解"><a href="#对-React-的理解" class="headerlink" title="对 React 的理解"></a>对 React 的理解</h3><ul><li>通过 Virtual DOM 和 Diff 算法隔离 DOM 操作。</li><li>采用单向数据流，数据流动方向单一，可跟踪。</li><li>组件化，JSX 自定义标签，便于抽象化。</li></ul><h3 id="对比-jQuery-开发的优势"><a href="#对比-jQuery-开发的优势" class="headerlink" title="对比 jQuery 开发的优势"></a>对比 jQuery 开发的优势</h3><ul><li>无需直接操作 DOM，事件通过改变 state 间接操作 DOM。</li></ul><p><img src="https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/lw0qj.jpg" alt="React-vs-jQuery.png"></p><h2 id="页面性能优化"><a href="#页面性能优化" class="headerlink" title="页面性能优化"></a>页面性能优化</h2><blockquote><p><strong>页面生成过程</strong></p><ul><li>HTML代码转化为DOM</li><li>CSS代码转化成CSSOM</li><li>结合DOM和CSSOM，生成一棵渲染树</li><li>生成布局（layout），即将所有渲染树的所有节点进行平面合成</li><li>将布局绘制（paint）在屏幕上</li></ul></blockquote><ul><li>减少 HTTP 请求（合并 CSS/JS，小于 10k 的图片 base64）</li><li>减少 DOM 操作（可使用 DocumentFragment）</li><li>避免不必要的重绘与重排（重排必定导致重绘）</li><li>优化 CSS 选择器（从右向左匹配）</li><li>CSS/JS minify，减少文件体积</li><li>开启 Gzip 压缩</li><li>将 CSS 放到顶部，JavaScript 放到尾部（JavaScript 会阻塞页面）</li><li>压缩图片以及使用 CSS Sprite</li><li>使用 CDN 加速，适当进行文件缓存</li><li>合理控制 cookie 大小（每次请求都会包含 cookie）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;答 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/25701897&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中级前端工程师面试 我想问的几个问题&lt;/a&gt; 中的几个问题，感谢 &lt;a href=&quot;https://www.zhihu.com/people/simplyy/answers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;@SimplyY
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;我最大的优势以及为什么选择前端&quot;&gt;&lt;a href=&quot;#我最大的优势以及为什么选择前端&quot; class=&quot;headerlink&quot; title=&quot;我最大的优势以及为什么选择前端&quot;&gt;&lt;/a&gt;我最大的优势以及为什么选择前端&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;我最大的优势是自学能力与理解能力强，并且不给自己套上『我是前端程序员』的枷锁，对于所有技术保持好奇心，不畏惧舒适圈外的事物并敢于尝试。&lt;/li&gt;
&lt;li&gt;选择前端的理由是，前端能够迅速的把想法实现，可选技术栈广泛（Web，移动端，桌面客户端），也是前端的优点之一。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://www.ahonn.me/categories/thinking/"/>
    
    
      <category term="前端" scheme="http://www.ahonn.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="面试" scheme="http://www.ahonn.me/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest 学习笔记</title>
    <link href="http://www.ahonn.me/2017/03/02/xmlhttprequest-study-notes/"/>
    <id>http://www.ahonn.me/2017/03/02/xmlhttprequest-study-notes/</id>
    <published>2017-03-02T10:35:39.000Z</published>
    <updated>2018-08-02T14:41:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。</p></blockquote><p>Ajax 技术的核心是 <code>XMLHttpRequest</code> 对象，起初 IE 首先引入这个特性，后面其他浏览器供应商也提供了相同的实现。</p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p>XMLHttpRequest 是一个API, 它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。</p><a id="more"></a><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul><li><p>open() 启动请求以备发送，参数包括请求方式，请求地址，是否异步</p></li><li><p>send() 发送请求，必要参数可发送请求主体数据，无数据时传入 null</p></li><li><p>abort() 发起异步请求时，终止请求</p></li><li><p>setRequestHeader() 设置请求头部信息</p></li><li><p>getRequestHeader() 获取请求头部信息</p></li><li><p>getAllRequestHeader() 获取全部请求头部信息，以字符串的形式返回</p></li></ul><h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><ul><li><p>status 响应的 HTTP 状态码</p></li><li><p>statusText 响应的 HTTP 状态说明</p></li><li><p>responseText 作为响应主体返回的文本</p></li><li><p>responseXML 响应数据中的 XML DOM 文档</p></li><li><p>readyState 请求/响应过程的当前活动阶段</p><ul><li><p>0 未初始化，没有使用 <code>open()</code></p></li><li><p>1 启动，调用 <code>open()</code> 但未调用 <code>send()</code></p></li><li><p>2 发送，已经调用 <code>send()</code>，但未接收到响应数据</p></li><li><p>3 接收，接收到部分响应数据</p></li><li><p>4 完成，接收到全部响应数据</p></li></ul></li></ul><h3 id="readystatechange-事件"><a href="#readystatechange-事件" class="headerlink" title="readystatechange 事件"></a>readystatechange 事件</h3><p>当 readyState 属性值改变时触发 readystatechange 事件。通过判断 readystate 属性的值，在完成请求响应整个过程之后执行某些操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ajax 技术的核心是 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 对象，起初 IE 首先引入这个特性，后面其他浏览器供应商也提供了相同的实现。&lt;/p&gt;
&lt;h2 id=&quot;XMLHttpRequest-对象&quot;&gt;&lt;a href=&quot;#XMLHttpRequest-对象&quot; class=&quot;headerlink&quot; title=&quot;XMLHttpRequest 对象&quot;&gt;&lt;/a&gt;XMLHttpRequest 对象&lt;/h2&gt;&lt;p&gt;XMLHttpRequest 是一个API, 它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://www.ahonn.me/categories/technology/"/>
    
    
      <category term="前端" scheme="http://www.ahonn.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.ahonn.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vim 折腾记</title>
    <link href="http://www.ahonn.me/2017/02/19/notes-of-vim/"/>
    <id>http://www.ahonn.me/2017/02/19/notes-of-vim/</id>
    <published>2017-02-19T14:37:54.000Z</published>
    <updated>2018-08-02T14:39:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天在微信读书上面看到了池建强的《MacTalk 人生元编程》，然后花了差不多一天看完，其中有篇有关于 Vim 的文章提起了我对这个编辑器的再一次兴趣（对的，我对它感兴趣很多次了，每次都懒..）。</p><p>一直懒得去慢慢配置它，又不想用别人的配置。自己用的编辑器还是想自己折腾，然后今天就趁着我对这个还有点热度赶紧折腾起来。</p><h2 id="MacVim"><a href="#MacVim" class="headerlink" title="MacVim"></a>MacVim</h2><p>其实在命令行里面直接写代码还有有些不习惯的，所以选了 MacVim 这个 GUI 版本。这样又可以与其他编辑器一样单独打开，想小改代码的时候又可以直接打开命令行搞。</p><p>在 MacTalk 的文章里面有提到 Vim 中文版本的<a href="http://sourceforge.net/projects/vimcdoc/files/latest/download" target="_blank" rel="noopener">帮助文档</a>，遂下载之。果然还是中文的比较浅显易懂。</p><p>以前看别人的 <code>.vimrc</code> 配置，里面有些编辑器的基本配置，也不知道是哪里查的。原来这些配置可以在编辑器中输入 <code>:help options</code> 进行查看。</p><a id="more"></a><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>关于缩进的配置，主要设置了 <code>autoindent</code>, <code>smartindent</code> 和 <code>expandtab</code> 这三个选项。</p><ul><li><code>autoindent</code> 选项根据上一行决定新行的缩进</li><li><code>smartindent</code> 选项智能自动缩进</li><li><code>expandtab</code> 选项将 tab 转换为空格</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set autoindent</span><br><span class="line">set smartindent</span><br><span class="line">set expandtab</span><br></pre></td></tr></table></figure><h3 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h3><p>显示行号是硬需求，但是与其他编辑器不同，在 vim 上还有相对行号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set number</span><br><span class="line">set relativenumber</span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>显而易见，手动安装 vim 插件是很麻烦很麻烦的。与 sublime text 之类的类似，vim 同样有类似的插件管理器 <a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener">Vundle</a>。</p><p>创建文件夹 <code>~/.vim</code> 和配置文件 <code>~/.vimrc</code>，并安装 Vundle:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle</span><br></pre></td></tr></table></figure><p>为了方便管理再新建一个 <code>.vimrc.bundles</code> 来单独存放插件列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set nocompatible    &quot; be iMproved, required</span><br><span class="line">filetype off        &quot; requried</span><br><span class="line">set rtp+=~/.vim/bundle/vundle/</span><br><span class="line"></span><br><span class="line">call vundle#begin()</span><br><span class="line"></span><br><span class="line">&quot; Let Vundle manage Vundle</span><br><span class="line">Bundle &apos;gmarik/vundle&apos;</span><br><span class="line"></span><br><span class="line">&quot; .... 其他插件</span><br><span class="line"></span><br><span class="line">call vundle#end()</span><br><span class="line">&quot; required</span><br><span class="line">filetype plugin indent on</span><br></pre></td></tr></table></figure><p>以后添加插件的时候只需要在这个文件里面添加一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bundle &apos;xxx&apos;</span><br></pre></td></tr></table></figure><p>安装插件输入 <code>:BundleInstall</code> 命令即可，卸载插件时删除对应的配置并运行 <code>:BundleClean</code> 删除插件。</p><h3 id="括号补全"><a href="#括号补全" class="headerlink" title="括号补全"></a>括号补全</h3><p>第一次用的时候，输入 <code>(</code> 居然没有自己蹦出来另外一个 <code>)</code>。这不科学，讲道理这个是一定要的。</p><p>发现很多人用的是 <a href="https://github.com/Raimondi/delimitMate" target="_blank" rel="noopener">delimitMate</a> ，添加 <code>Bundle &#39;delimitMate&#39;</code> 到 <code>.vimrc.bundles</code>，运行 <code>BundleInstall</code>。</p><p>安装完直接就可以自动补全括号了。</p><h3 id="Emmet"><a href="#Emmet" class="headerlink" title="Emmet"></a>Emmet</h3><p>很多浏览器都支持 Emmet 插件，vim 同样也有。但这个 Emmet 是第三方的，叫 <a href="https://github.com/mattn/emmet-vim/" target="_blank" rel="noopener">Emmet.vim</a>。</p><p>安装完之后主要是设置一下出发的快捷键，默认的快捷键是 <code>Ctrl + y</code>。<br>我把快捷键修改成 <code>Ctrl + e</code> 比较顺手。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; Emmet.vim</span><br><span class="line">let g:user_emmet_expandabbr_key = &apos;&lt;c-e&gt;&apos;</span><br></pre></td></tr></table></figure><h3 id="目录树"><a href="#目录树" class="headerlink" title="目录树"></a>目录树</h3><p>目录树就基本上也就是使用 <a href="https://github.com/scrooloose/nerdtree" target="_blank" rel="noopener">NERDTree</a>。</p><p>开启目录树的快捷键修改为 <code>Ctrl + b</code>，然后当 vim 只剩目录树显示的时候自动退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot; NERDTree</span><br><span class="line">map &lt;c-b&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">autocmd vimenter * NERDTree</span><br><span class="line">autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTreeType&quot;) &amp;&amp;b:NERDTreeType == &quot;primary&quot;) | q | endif</span><br></pre></td></tr></table></figure></p><h3 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h3><p>补全用的就是大名鼎鼎的 <a href="https://github.com/Valloric/YouCompleteMe" target="_blank" rel="noopener">YouCompleteMe</a> 了。</p><p>关于这个插件网上有很多插件，我就不啰嗦了。这里主要是抄的百度 EFE 的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&quot; YouCompleteMe</span><br><span class="line">&quot; http://efe.baidu.com/blog/vim-javascript-completion/#youcompleteme</span><br><span class="line">let g:ycm_min_num_of_chars_for_completion = 3</span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion=1</span><br><span class="line">let g:ycm_complete_in_comments = 1</span><br><span class="line">let g:ycm_key_list_select_completion = [&apos;&lt;c-n&gt;&apos;, &apos;&lt;Down&gt;&apos;]</span><br><span class="line">let g:ycm_key_list_previous_completion = [&apos;&lt;c-p&gt;&apos;, &apos;&lt;Up&gt;&apos;]</span><br><span class="line">&quot; Use tab</span><br><span class="line">function! TabFunction ()</span><br><span class="line">    let line = getline(&apos;.&apos;)</span><br><span class="line">    let substr = strpart(line, -1, col(&apos;.&apos;)+1)</span><br><span class="line">    let substr = matchstr(substr, &quot;[^ \t]*$&quot;)</span><br><span class="line">    if strlen(substr) == 0</span><br><span class="line">        return &quot;\&lt;tab&gt;&quot;</span><br><span class="line">    endif</span><br><span class="line">    return pumvisible() ? &quot;\&lt;c-n&gt;&quot; : &quot;\&lt;c-x&gt;\&lt;c-o&gt;&quot;</span><br><span class="line">endfunction</span><br><span class="line">inoremap &lt;tab&gt; &lt;c-r&gt;=TabFunction()&lt;cr&gt;</span><br><span class="line"></span><br><span class="line">let g:ycm_semantic_triggers = &#123;</span><br><span class="line">    \   &apos;css&apos;: [ &apos;re!^\s&#123;2&#125;&apos;, &apos;re!:\s+&apos;],</span><br><span class="line">    \   &apos;html&apos;: [ &apos;&lt;/&apos; ],</span><br><span class="line">    \ &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>折腾了一下午，终于算是搞定了。其实过程还是蛮好玩的，有机会还想写写插件玩玩。抛弃 VS Code，开始 Vim 之旅感。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天在微信读书上面看到了池建强的《MacTalk 人生元编程》，然后花了差不多一天看完，其中有篇有关于 Vim 的文章提起了我对这个编辑器的再一次兴趣（对的，我对它感兴趣很多次了，每次都懒..）。&lt;/p&gt;
&lt;p&gt;一直懒得去慢慢配置它，又不想用别人的配置。自己用的编辑器还是想自己折腾，然后今天就趁着我对这个还有点热度赶紧折腾起来。&lt;/p&gt;
&lt;h2 id=&quot;MacVim&quot;&gt;&lt;a href=&quot;#MacVim&quot; class=&quot;headerlink&quot; title=&quot;MacVim&quot;&gt;&lt;/a&gt;MacVim&lt;/h2&gt;&lt;p&gt;其实在命令行里面直接写代码还有有些不习惯的，所以选了 MacVim 这个 GUI 版本。这样又可以与其他编辑器一样单独打开，想小改代码的时候又可以直接打开命令行搞。&lt;/p&gt;
&lt;p&gt;在 MacTalk 的文章里面有提到 Vim 中文版本的&lt;a href=&quot;http://sourceforge.net/projects/vimcdoc/files/latest/download&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;帮助文档&lt;/a&gt;，遂下载之。果然还是中文的比较浅显易懂。&lt;/p&gt;
&lt;p&gt;以前看别人的 &lt;code&gt;.vimrc&lt;/code&gt; 配置，里面有些编辑器的基本配置，也不知道是哪里查的。原来这些配置可以在编辑器中输入 &lt;code&gt;:help options&lt;/code&gt; 进行查看。&lt;/p&gt;
    
    </summary>
    
      <category term="折腾工具" scheme="http://www.ahonn.me/categories/tool/"/>
    
    
      <category term="Vim" scheme="http://www.ahonn.me/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 继承的那些事</title>
    <link href="http://www.ahonn.me/2017/01/24/something-about-javaScript-inherit/"/>
    <id>http://www.ahonn.me/2017/01/24/something-about-javaScript-inherit/</id>
    <published>2017-01-24T15:15:02.000Z</published>
    <updated>2018-08-02T14:39:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，JavaScript 的继承是实现继承，而没有 Java 中的接口继承。这是因为 JavaScript 中函数没有签名，而实现继承依靠的是原型链来实现的。</p><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>JavaScript 中通过修改对象原型指向的对象来实现继承，即是将一个对象的原型指向要继承的对象实例，从而实现继承对象的属性及方法。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'super'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getType() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'sub'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(sub.getType()); <span class="comment">// "sub"</span></span><br></pre></td></tr></table></figure><h3 id="原型链继承的不足"><a href="#原型链继承的不足" class="headerlink" title="原型链继承的不足"></a>原型链继承的不足</h3><p>实际上，上面的代码还缺少一句代码，我们将 SubType 的原型指向了 SuperType 的实例，即<code>SubType.prototype.constructor</code> 会返回 <code>SuperType</code> 而不是 <code>SubType</code>，使用 <code>instanceof</code> 操作符返回的将是 <code>SuperType</code>。所以需要将 <code>SubType.prototype.constructor</code> 重新指向 <code>SubType</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>但即使是这样，原型链继承依然有两点问题：原型中的实例引用类型属性会在所有对象实例中共享，无法想 Java 的继承一样向父类的构造函数中传递参数。</p><h2 id="其他继承方式"><a href="#其他继承方式" class="headerlink" title="其他继承方式"></a>其他继承方式</h2><p>由于原型链继承存在一些不足，为了解决这些不足，JavaScript 中还有其他的几种继承的方式。</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>因为原型链无法传递参数到父类的构造函数中，因此出现了这种叫做借用构造函数的技术。顾名思义，即是借用父类的构造函数在子类中进行调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>); <span class="comment">// &lt;- 执行父类构造函数</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借用构造函数虽然解决了构造函数传参的问题，但是当父类拥有方法时每个子类的实例都会拥有独立的方法，这个问题与单独使用构造函数模式定义类型的时候相同。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>类比使用构造函数模式定义类型时的解决方法（组合构造函数模式与原型模式），继承时的解决方法也类似。即组合原型链继承和借用构造函数，属性由借用构造函数的方式继承，方法由原型链继承。</p><p>实际上也就是在原型链继承的代码中添加在子类的构造函数中调用父类构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'super'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getType() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'sub'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br></pre></td></tr></table></figure><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>组合继承是常用的继承方式，但是同样的也是有不足之处：调用了两次父类的构造函数，一次在子类构造函数中调用父类构造函数，一次在实例父类对象赋值给子类的原型。</p><p>寄生组合式继承在指定子类的原型的时候不必调用父类的构造函数，而是直接使用 <code>Object.create()</code> 创建父类原型的副本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="built_in">Object</span>.create(SuperType.prototype); <span class="comment">// 直接使用父类原型创建副本</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br></pre></td></tr></table></figure><h2 id="ES6-中的继承"><a href="#ES6-中的继承" class="headerlink" title="ES6 中的继承"></a>ES6 中的继承</h2><p>ES6 引入了 <code>class</code> 关键子，可以像其他语言中一样使用 <code>extends</code> 关键字来继承。虽然能够使用 <code>extends</code> 实现继承，但实际上内部还是基于原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，JavaScript 的继承是实现继承，而没有 Java 中的接口继承。这是因为 JavaScript 中函数没有签名，而实现继承依靠的是原型链来实现的。&lt;/p&gt;
&lt;h2 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;headerlink&quot; title=&quot;原型链继承&quot;&gt;&lt;/a&gt;原型链继承&lt;/h2&gt;&lt;p&gt;JavaScript 中通过修改对象原型指向的对象来实现继承，即是将一个对象的原型指向要继承的对象实例，从而实现继承对象的属性及方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://www.ahonn.me/categories/technology/"/>
    
    
      <category term="前端" scheme="http://www.ahonn.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.ahonn.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>从零开始制作 Hexo 主题</title>
    <link href="http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/"/>
    <id>http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/</id>
    <published>2016-12-15T09:43:47.000Z</published>
    <updated>2018-09-14T16:16:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文将会从零开始开发一个简单的博客主题。样式主要参考 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo theme</a> 中的 <a href="https://github.com/lotabout/hexo-theme-noise" target="_blank" rel="noopener">Noise</a> 主题。</p><p>开始之前你需要了解：</p><ul><li>模板引擎</li><li>CSS预处理器</li><li>Hexo 文档</li></ul><p>本文使用的模板引擎为 <a href="http://www.embeddedjs.com/" target="_blank" rel="noopener">ejs</a>，使用的 CSS 预处理器为 <a href="http://stylus-lang.com/" target="_blank" rel="noopener">stylus</a>。这也是 hexo 项目预装了的 render 插件，如果想使用其他模板引擎或者其他 CSS 预处理器，可以安装相对应的 render 插件。例如我的 <a href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a> 主题使用的是 Swig 与 SCSS。</p><p>本文的代码： <a href="https://github.com/ahonn/theme-example" target="_blank" rel="noopener">theme-example</a> 。</p><a id="more"></a><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>主题目录结构以自带的 <a href="https://github.com/hexojs/hexo-theme-landscape" target="_blank" rel="noopener">landscape</a> 主题为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── languages  语言文件，用于国际化</span><br><span class="line">├── layout     页面模板文件</span><br><span class="line">├── scripts    Hexo 脚本</span><br><span class="line">└── source     主题资源文件，包括页面样式，脚本，字体等</span><br></pre></td></tr></table></figure><p>我们在 <code>themes</code> 中新建 <code>theme-example</code> 文件夹，然后在 <code>theme-example</code> 中按照 landscape 主题的目录结构新建 <code>languages</code>，<code>layout</code>，<code>scripts</code> 与 <code>source</code> 文件夹。</p><h2 id="创建布局模板"><a href="#创建布局模板" class="headerlink" title="创建布局模板"></a>创建布局模板</h2><p>在 <code>layout</code> 中创建 <code>index.ejs</code> 文件，首页将会使用该布局模板生成 HTML 文件。</p><p><code>layout/index.ejs</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Word<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改站点配置文件中的主题配置，使用我们刚刚创建的 <code>theme-example</code> 主题：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">theme-example</span></span><br></pre></td></tr></table></figure><p>运行 <code>hexo server --debug</code> 以 debug 模式开启 Hexo 本地服务器预览，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>。</p><p><img src="https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/6up8p.jpg" alt="Hello World"></p><h2 id="添加页面导航"><a href="#添加页面导航" class="headerlink" title="添加页面导航"></a>添加页面导航</h2><p>现在我们需要在页面中添加导航，由于导航不单单会在首页出现，所以我们在 <code>layout</code> 中创建共用的布局文件 <code>layout.ejs</code>， 同时创建 <code>_partial/head.ejs</code> 保存 HTML 的 head 以及创建 <code>_partial/header.ejs</code> 文件，编写页面导航部分。</p><p><code>layout/layout.ejs</code>:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">_partial</span>/<span class="attr">head</span>') %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">_partial</span>/<span class="attr">header</span>') %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%-</span> <span class="attr">body</span> %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>layout.ejs</code> 文件通过 <code>partial()</code> 函数来包含其他文件，使得我们能够更好的组织代码。详见 <a href="https://hexo.io/docs/templates.html#Partials" target="_blank" rel="noopener">Templates | Hexo</a>。</p><p><code>layout/_partial/head.ejs</code>:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里使用了 <code>config</code> 变量，该变量包含的是站点配置（即站点根目录下 <code>_config.yml</code> 中的配置）。除此之外，Hexo 还提供了许多变量可在模板中使用，详见 <a href="https://hexo.io/docs/variables.html" target="_blank" rel="noopener">Variables | Hexo</a>。</p><p><code>layout/_partial/header.ejs</code>:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blog-title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for() %&gt;"</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu-item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">class</span>=<span class="string">"menu-item-link"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu-item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/archives"</span> <span class="attr">class</span>=<span class="string">"menu-item-link"</span>&gt;</span>Archive<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>接着我们清空 <code>index.ejs</code> 中的内容，并添加 <code>&lt;h2&gt;Hello World&lt;/h2&gt;</code>。在 <code>layout</code> 目录下的 <code>index.ejs</code> 会自动继承 <code>layout.ejs</code>，并将其中的内容填入 <code>&lt;%- body %&gt;</code> 的位置。我们将得到一个有导航菜单的 Hello World 页面。</p><p><img src="https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/v7x9h.jpg" alt="Index"></p><h2 id="添加主题配置文件"><a href="#添加主题配置文件" class="headerlink" title="添加主题配置文件"></a>添加主题配置文件</h2><p>实际上我们需要让导航菜单根据我们的需要显示不同的项，上面这种写法不方便修改。所以我们会在主题的配置文件中添加导航菜单的配置。在 <code>thmem-demo</code> 下新建主题的配置文件 <code>_config.yml</code>，在其中添加需要配置的字段。然后可以通过 <code>theme</code> 这个变量来拿到该配置文件中的配置。</p><p><code>theme-example/_config.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  Home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">/archives</span></span><br></pre></td></tr></table></figure><p>这样我们就可以在 <code>header.ejs</code> 中使用 <code>theme.menu</code> 获取到导航菜单的设置。将 <code>header.ejs</code> 修改为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blog-title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for() %&gt;"</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span> (<span class="attr">name</span> <span class="attr">in</span> <span class="attr">theme.menu</span>) &#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu-item"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(theme.menu[name]) %&gt;"</span> <span class="attr">class</span>=<span class="string">"menu-item-link"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">name</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当需要在导航中添加链接的时候就可以在配置文件中直接添加，例如添加 Github 的链接：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  Home:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">/archives</span></span><br><span class="line"><span class="attr">  Github:</span> <span class="attr">https://github.com/ahonn</span></span><br></pre></td></tr></table></figure><p>除此之外还可以添加其他需要的配置，例如 RSS，评论等等。</p><h2 id="添加首页文章列表"><a href="#添加首页文章列表" class="headerlink" title="添加首页文章列表"></a>添加首页文章列表</h2><p>接着我们完善首页的模板，使其能够显示文章列表。前面已经说过 Hexo 提供了各种有用的变量，在这里将会使用到 <code>page</code> 这个变量。<code>page</code> 会根据不同的页面拥有不同的属性。具体有什么属性，可以获取到哪些数据可以查看<a href="https://hexo.io/docs/variables.html#Page-Variables" target="_blank" rel="noopener">这里</a>。</p><p>那么这里我们会使用 <code>page</code> 变量的 <code>posts</code> 属性拿到文章数据的集合。编辑 <code>index.ejs</code> 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"posts"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">page.posts.each</span>(<span class="attr">function</span> (<span class="attr">post</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"post-title-link"</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(post.path) %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">post.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%-</span> <span class="attr">post.content</span> %&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-meta"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span> <span class="attr">date</span>(<span class="attr">post.date</span>, "<span class="attr">YYYY-MM-DD</span>") %&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从 <code>page.posts</code> 中获取单篇文章的数据，并获取文章的标题，内容等数据填充到模板中。处理文章创建时间的时候使用了 <code>date()</code> 函数，这是 Hexo 提供的时间处理的<a href="https://hexo.io/docs/helpers.html#date" target="_blank" rel="noopener">辅助函数</a>。本文中使用到的函数如无特别说明，即为 Hexo 的辅助函数。</p><h3 id="文章摘录"><a href="#文章摘录" class="headerlink" title="文章摘录"></a>文章摘录</h3><p>由于首页显示文章内容时使用的是 <code>post.content</code>，即文章的全部内容。所以首页会显示每一篇文章的内容，实际上我们并不想在首页显示那么多内容，只想显示文章的摘录。</p><p>Hexo 提供了 <code>excerpt</code> 属性来获取文章的摘录部分，不过这里需要在文章中添加一个 <code>&lt;!--more--&gt;</code> 标记。添加了这个标记之后，<code>post.excerpt</code> 将会获取到标记之前的内容。如果没有这个标记，那么 <code>post.excerpt</code> 会是空的。所以我们可以把首页文章内容部分的 <code>post.content</code> 替换成 <code>post.excerpt</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-content"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">post.excerpt</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加页面样式"><a href="#添加页面样式" class="headerlink" title="添加页面样式"></a>添加页面样式</h2><p>到目前为止，我们完成了首页的页面结构，但是并没有添加样式，所以看起来很丑。我们在 <code>source</code> 文件中创建一个 <code>css</code> 文件夹来存放样式文件。</p><p>由于 Hexo 在新建项目的时候会安装 <code>hexo-renderer-stylus</code> 这个插件，所以我们无需其他步骤，只需要将样式文件放到 <code>css</code> 文件夹中。Hexo 在生成页面的时候会将 <code>source</code> 中的所有文件复制到生成的 <code>public</code> 文件中，并且在此之前会编译 styl 为 css 文件。</p><p>在 <code>css</code> 文件夹中创建 <code>style.styl</code>，编写一些基础的样式，并把所有样式 <code>import</code> 到这个文件。所以最终编译之后只会有 <code>style.css</code> 一个文件。创建 <code>_partial/header.styl</code> 与 <code>_partial/post.styl</code> 存放页面导航以及文章的样式，并且在 <code>style.styl</code> 中 <code>import</code> 这两个文件。</p><p><code>_partial/header.styl</code>:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">2em</span></span><br><span class="line">  <span class="attribute">display</span>: flex</span><br><span class="line">  <span class="attribute">align-items</span>: baseline</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.blog-title</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#AAA</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2em</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">"Comic Sans MS"</span>,cursive,LiSu,sans-serif;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.menu</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.menu-item</span> &#123;</span><br><span class="line">      <span class="attribute">display</span>: inline-block;</span><br><span class="line">      <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.menu-item-link</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#AAA</span>;</span><br><span class="line">      <span class="attribute">text-decoration</span>: none;</span><br><span class="line"></span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#368CCB</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_partial/post.style</code>:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.posts</span>  &#123;</span><br><span class="line">  <span class="selector-class">.post</span>:first-child &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.post-title</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">1.5em</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.post-title-link</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#368CCB</span>;</span><br><span class="line">      <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.post-content</span> &#123;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#368CCB</span>;</span><br><span class="line">      <span class="attribute">text-decoration</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.post-meta</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#BABABA</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>style.styl</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#F2F2F2</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.25rem</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@import "_partial/header";</span><br><span class="line">@import "_partial/post";</span><br></pre></td></tr></table></figure><p>最后，我们需要把样式添加到页面中，这里使用了另外一个辅助函数 <a href="https://hexo.io/docs/helpers.html#css" target="_blank" rel="noopener"><code>css()</code></a>:</p><p><code>layout/_partial/head.ejs</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%-</span> <span class="attr">css</span>('<span class="attr">css</span>/<span class="attr">style.css</span>') %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>至此，我们会看到站点的首页是这个样子的：</p><p><img src="https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/z38nr.jpg" alt="Home Page"></p><p><strong>注意，这里会报错。原因是生成文章页时没有找到对应的模版，所以使用了首页的模版，但文章页并没有 <code>page.posts</code> 这个属性（undefined 没有 each 方法）。新建 post.ejs 即可解决，或直接跳过直到完成文章页模版。</strong></p><h2 id="添加分页"><a href="#添加分页" class="headerlink" title="添加分页"></a>添加分页</h2><p>在站点的 <code>source/_post/</code> 目录下存放的是我们的文章，现在我们把原本的 <code>hello-world.md</code> 复制黏贴 10+ 次，再查看站点首页。会发现，首页只显示了 10 篇文章。</p><p>首页显示的文章数量我们可以通过站点配置文件中的 <code>per_page</code> 字段来修改，但是我们不可能把所有文章都放在一页，所以我们现在来添加文章列表的分页。</p><p>新建 <code>_partial/paginator.ejs</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">page.total</span> &gt;</span> 1)&#123; %&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"page-nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">paginator</span>(&#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">prev_text:</span> "&amp;<span class="attr">laquo</span>; <span class="attr">Prev</span>",</span></span><br><span class="line"><span class="tag">      <span class="attr">next_text:</span> "<span class="attr">Next</span> &amp;<span class="attr">raquo</span>;"</span></span><br><span class="line"><span class="tag">    &#125;) %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>index.ejs</code> 中添加这个文件的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">_partial</span>/<span class="attr">paginator</span>') %&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们使用到了另外的一个辅助函数 <a href="https://hexo.io/docs/helpers.html#paginator" target="_blank" rel="noopener"><code>paginator</code></a>，它能够帮助我们插入分页链接。</p><h2 id="添加文章详情页"><a href="#添加文章详情页" class="headerlink" title="添加文章详情页"></a>添加文章详情页</h2><p>文章详情页对应的布局文件是 <code>post.ejs</code>，新建 <code>post.ejs</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">page.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-meta"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-time"</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span> <span class="attr">date</span>(<span class="attr">page.date</span>, "<span class="attr">YYYY-MM-DD</span>") %&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">page.content</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于这里是文章的模板，所以变量 <code>page</code> 表示的是文章的数据，而不是首页的文章数据集合。</p><h2 id="添加归档页"><a href="#添加归档页" class="headerlink" title="添加归档页"></a>添加归档页</h2><p>创建归档页使用的模板文件 <code>archive.ejs</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"archive"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"post-archive"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">page.posts.each</span>(<span class="attr">function</span> (<span class="attr">post</span>) &#123; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-item"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-date"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">date</span>(<span class="attr">post.date</span>, "<span class="attr">YYYY-MM-DD</span>") %&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"post-title"</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(post.path) %&gt;"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">post.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>('<span class="attr">_partial</span>/<span class="attr">paginator</span>') %&gt;</span></span><br></pre></td></tr></table></figure><p>其实结构跟首页差不多，只是不显示文章内容而已。添加归档页的样式：</p><p><code>css/_partial/archive.styl</code>:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.archive</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> <span class="number">#ddd</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.post-archive</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.post-item</span> &#123;</span><br><span class="line">      <span class="attribute">margin</span>: <span class="number">5px</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="selector-class">.post-date</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: inline-block;</span><br><span class="line">        <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#BABABA</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="selector-class">.post-title</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#368CCB</span>;</span><br><span class="line">        <span class="attribute">text-decoration</span>: none;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><p>还记得我们一开始创建的 <code>languages</code> 文件夹吗？没错，它是用来添加多种语言，用于 i18n 的。站点的语言设置为站点配置文件中的 <code>language</code>。</p><p>当该字段为空时，默认使用的是 <code>languages/default.yml</code> 这个文件。那么现在我们来添加这个文件，我们决定主题的默认语言是英文：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Menu:</span></span><br><span class="line"><span class="attr">  Home:</span> <span class="string">Home</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">Archives</span></span><br><span class="line"><span class="attr">  Github:</span> <span class="string">Github</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Paginator:</span></span><br><span class="line"><span class="attr">  Prev:</span> <span class="string">Prev</span></span><br><span class="line"><span class="attr">  Next:</span> <span class="string">Next</span></span><br></pre></td></tr></table></figure><p>目前我们需要主题根据选择的语言自动修改的有上面这些，接着我们需要修改 <code>header.ejs</code> 与 <code>paginator.ejs</code> 这两个文件：</p><p><code>_partial/header.ejs</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blog-title"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for() %&gt;"</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">config.title</span> %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"navbar"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> <span class="attr">for</span> (<span class="attr">name</span> <span class="attr">in</span> <span class="attr">theme.menu</span>) &#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"menu-item"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for(theme.menu[name]) %&gt;"</span> <span class="attr">class</span>=<span class="string">"menu-item-link"</span>&gt;</span><span class="tag">&lt;<span class="name">%-</span> <span class="attr">__</span>('<span class="attr">Menu.</span>' + <span class="attr">name</span>) %&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>_partial/paginator.ejs</code>:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">page.total</span> &gt;</span> 1)&#123; %&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"page-nav"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%-</span> <span class="attr">paginator</span>(&#123;</span></span><br><span class="line"><span class="tag">      <span class="attr">prev_text:</span> "&amp;<span class="attr">laquo</span>;" + <span class="attr">__</span>('<span class="attr">Paginator.Prev</span>'),</span></span><br><span class="line"><span class="tag">      <span class="attr">next_text:</span> <span class="attr">__</span>('<span class="attr">Paginator.Next</span>') + "&amp;<span class="attr">raquo</span>;"</span></span><br><span class="line"><span class="tag">    &#125;) %&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure></p><p>修改之后其实与之前相比没有什么变化，起码看起来是。现在我们添加一个中文的文件：</p><p><code>languages/zh-CN.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Menu:</span></span><br><span class="line"><span class="attr">  Home:</span> <span class="string">首页</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">归档</span></span><br><span class="line"><span class="attr">  Github:</span> <span class="string">交友</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Paginator:</span></span><br><span class="line"><span class="attr">  Prev:</span> <span class="string">上一页</span></span><br><span class="line"><span class="attr">  Next:</span> <span class="string">下一页</span></span><br></pre></td></tr></table></figure></p><p>然后我们将站点配置文件中的 <code>language</code> 字段修改为 <code>zh-CN</code>（与 <code>zh-CN.yml</code> 文件名相同）。再次访问站点之后就会发现导航与分页部分的文字变成了中文。</p><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>如果你有耐心看我废话了这么多的话，恭喜你，你应该对怎么去写一个 Hexo 主题有了一定的了解。其实说白了，Hexo 就是把那些 Markdown 文件按照不同的布局模板，填上对应的数据生成 HTML 页面，复制 <code>source</code> 中的到生成的 <code>public</code> 文件夹中，中间过程会把需要编译的 stylus/less/sass 等文件编译。</p><p>本文并没有提及有关页面 JavaScript 的部分，实际上与写 CSS 样式相同。在 <code>source/js</code> 中写 JavaScript 脚本，然后在模板中引入即可。</p><p>感谢阅读，希望对你有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;本文将会从零开始开发一个简单的博客主题。样式主要参考 &lt;a href=&quot;https://hexo.io/themes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo theme&lt;/a&gt; 中的 &lt;a href=&quot;https://github.com/lotabout/hexo-theme-noise&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Noise&lt;/a&gt; 主题。&lt;/p&gt;
&lt;p&gt;开始之前你需要了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模板引擎&lt;/li&gt;
&lt;li&gt;CSS预处理器&lt;/li&gt;
&lt;li&gt;Hexo 文档&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文使用的模板引擎为 &lt;a href=&quot;http://www.embeddedjs.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ejs&lt;/a&gt;，使用的 CSS 预处理器为 &lt;a href=&quot;http://stylus-lang.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stylus&lt;/a&gt;。这也是 hexo 项目预装了的 render 插件，如果想使用其他模板引擎或者其他 CSS 预处理器，可以安装相对应的 render 插件。例如我的 &lt;a href=&quot;https://github.com/ahonn/hexo-theme-even&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Even&lt;/a&gt; 主题使用的是 Swig 与 SCSS。&lt;/p&gt;
&lt;p&gt;本文的代码： &lt;a href=&quot;https://github.com/ahonn/theme-example&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;theme-example&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://www.ahonn.me/categories/thinking/"/>
    
    
      <category term="前端" scheme="http://www.ahonn.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Hexo" scheme="http://www.ahonn.me/tags/Hexo/"/>
    
      <category term="从零开始" scheme="http://www.ahonn.me/tags/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/"/>
    
  </entry>
  
  <entry>
    <title>2016 年终总结</title>
    <link href="http://www.ahonn.me/2016/12/13/2016-summary/"/>
    <id>http://www.ahonn.me/2016/12/13/2016-summary/</id>
    <published>2016-12-13T03:23:09.000Z</published>
    <updated>2018-09-14T16:15:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>一转眼 2016 年就快要结束了，这一年对自己来说收获了很多。</p><p>去年的总结，给自己定下了个 2016 年的计划。现在 2016 也差不多快结束了，我对自己执行的情况还是比较满意的。</p><h2 id="关于-Github"><a href="#关于-Github" class="headerlink" title="关于 Github"></a>关于 Github</h2><p>去年年底参加了 Github 上的一个编程马拉松，一开始 commit 都是没有断过的，但是之后慢慢的总会有抓脑袋想 commit 的状况出现。不能说这样不好，只不过会让自己为了 commit 而 commit，本末倒置了。所以后面就不再管是否连续 commit 了，也把之前几个自己觉得不行的项目给删除了。贴一张今年 Github 上的 commit 图，虽然还是有很多质量不高的提交，但也算是今年对自己的付出的一点交代了。</p><p><img src="https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/m37e8.jpg" alt="Github Commit"></p><a id="more"></a><p>大多数的提交都贡献自 <a href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">hexo-theme-even</a> 这个项目。放假在家的时候突然想自己写个博客的主题，结果说干就干，就写起来了。到目前为止已经重构了两遍了，每一次都能够发现之前写的不好的地方。不过在这个过程中明白了一点，不能为了写代码而写代码，应该更加关注用户体验。之前写的时候完全是自己能用就好的，后来使用的人越来越多了，就需要关注一些之前自己不会关注到的点。</p><p>更深刻的体会到，设计与规划应该占到的比重应该远远大于编码的比重。这就好比盖房子，一股脑的搬砖盖最后可能盖出来的是歪楼。</p><h2 id="关于实习"><a href="#关于实习" class="headerlink" title="关于实习"></a>关于实习</h2><p>暑假的时候没有回家，找了一个技术相关的暑假实习。当然，所谓暑假实习就是打打下手咯。不过期间也参与了个很有意思的项目，不过因为是比较偏重后端的公司（使用的大多是 Ruby），所以前端部分都是自己折腾，没有学到什么东西。</p><p>在实习期间也学到了非常多的东西，比如说怎么使用 git 进行团队协作，写页面的时候要注重用户体验，一个按钮或者一个文本的位置都需要慎重思考。由于公司比较小，感受不到比较浓厚的技术气氛。所以希望大三结束的这份实习能够找到自己所期望的那样技术气氛浓厚的公司来实习。</p><h2 id="关于读书"><a href="#关于读书" class="headerlink" title="关于读书"></a>关于读书</h2><p>暑假实习的时候由于是一个人住，每天上下班都要在地铁上花费一个多钟的时间。所以在一开始的时候就用了京东白条预先买了个 Kindle，然后在实习的这段时间里看完了《乔布斯传》，《解忧杂货店》，《人性的弱点》以及《安静》。关于读书，想起了一个知乎上的一个回答：<a href="https://www.zhihu.com/question/22456239/answer/45671305" target="_blank" rel="noopener">读了很多书，但是都忘掉了，读书的意义在哪里？ - 尧大力的回答 - 知乎</a>，深以为然。读书对我的影响还是很大的，会改变对事物的看法。不是有句话说，读万卷书，行万里路。所以要多读书，以后有机会的话也要多出去走走。</p><p>除了看这些书之外，也看了一些技术性的书籍。实习之前看了本《深入理解 bootstrap》，这个在我实习的时候用 bootstrap 的时候有很大帮助。还有一些 JavaScript 相关的书，高程三打算在大三实习之前再刷多一次。</p><p>有点小遗憾的是，我依旧没有看完 SICP（Structure and Interpretation of Computer Programs<br>），看了前两章就没有看了。所以明年的计划里面会加上看完这本书。此外，双十一的时候也买了好几本技术类书籍，其实都是为了到时候面试而准备的，正好也是需要补补基础。其实更关键的一点是太穷只能买书了…</p><h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p>今年回家的时间比较少，前半年在学校，后半年在学校，中间实习在广州一个人住。第一次离家还是一个人生活，让我这样一个不会照顾自己的人也慢慢的学会了照顾自己。同时也明白了很多事情，一个人的时候要好好的，不能让父母担心。</p><h2 id="关于来年"><a href="#关于来年" class="headerlink" title="关于来年"></a>关于来年</h2><p>2018 年就正式毕业了，也就是说在学校的时间不多了，希望自己能好好过完这最后的学生时光。</p><p>无例外，今年的总结也要对新的一年列个计划。</p><ul><li>继续好好维护博客主题</li><li>完成 leetcode 上的前 150 道题目</li><li>读完买的那些书，包括不限于高程三，SICP</li><li>写自己的简历网站</li><li>多运动，久坐对身体不好</li><li>有机会多出去走走</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一转眼 2016 年就快要结束了，这一年对自己来说收获了很多。&lt;/p&gt;
&lt;p&gt;去年的总结，给自己定下了个 2016 年的计划。现在 2016 也差不多快结束了，我对自己执行的情况还是比较满意的。&lt;/p&gt;
&lt;h2 id=&quot;关于-Github&quot;&gt;&lt;a href=&quot;#关于-Github&quot; class=&quot;headerlink&quot; title=&quot;关于 Github&quot;&gt;&lt;/a&gt;关于 Github&lt;/h2&gt;&lt;p&gt;去年年底参加了 Github 上的一个编程马拉松，一开始 commit 都是没有断过的，但是之后慢慢的总会有抓脑袋想 commit 的状况出现。不能说这样不好，只不过会让自己为了 commit 而 commit，本末倒置了。所以后面就不再管是否连续 commit 了，也把之前几个自己觉得不行的项目给删除了。贴一张今年 Github 上的 commit 图，虽然还是有很多质量不高的提交，但也算是今年对自己的付出的一点交代了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ahonn-me.oss-cn-beijing.aliyuncs.com/images/m37e8.jpg&quot; alt=&quot;Github Commit&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="思考总结" scheme="http://www.ahonn.me/categories/thinking/"/>
    
    
      <category term="年终总结" scheme="http://www.ahonn.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 创建对象的一些姿势</title>
    <link href="http://www.ahonn.me/2016/11/30/some-ways-of-javascript-create-object/"/>
    <id>http://www.ahonn.me/2016/11/30/some-ways-of-javascript-create-object/</id>
    <published>2016-11-30T10:52:21.000Z</published>
    <updated>2018-08-02T14:39:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在函数中创建 Object 对象，并为对象添加属性。函数返回添加属性之后的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = createPerson(<span class="string">"ahonn"</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>但工厂模式产生的对象依旧为 Object 类型，只是在对象上添加了一些属性。</p><blockquote><p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）</p></blockquote><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>由于工厂模式创建的对象没有解决对象识别的问题，出现了另外一种新模式：构造函数模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"ahonn"</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>这里使用了 <code>new</code> 操作符，即是将 Person 函数通过构造函数的方式去调用来创建对象。</p><p>构造函数会进行下面几个步骤：</p><ul><li>创建一个新对象</li><li>将构造函数的 this 指向新对象</li><li>通过 this 给对象添加属性</li><li>返回新对象</li></ul><p>使用构造函数模式创建的对象可以通过 <code>constructor</code> 属性查看对象的类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p.constructor) <span class="comment">// Person</span></span><br></pre></td></tr></table></figure><h3 id="构造函数也是普通函数"><a href="#构造函数也是普通函数" class="headerlink" title="构造函数也是普通函数"></a>构造函数也是普通函数</h3><p>构造函数与普通的函数无异，也可以直接调用构造函数。但此时就不会创建新对象，函数中的 this 指向的是函数当前所在的作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="string">"ahonn"</span>, <span class="number">21</span>)</span><br><span class="line"><span class="keyword">this</span>.sayName() <span class="comment">// ahonn</span></span><br></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>通过构造函数模式创建的对象有一个问题，就是创建的对象各自拥有自己的方法，而实际上这些方法都是相同的。通过原型模式即可以将共同的属性方法放在 prototype 上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"ahonn"</span></span><br><span class="line">Person.prototype.age = <span class="number">21</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1.sayName() <span class="comment">// "ahonn"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line">p2.sayName() <span class="comment">// "ahonn"</span></span><br></pre></td></tr></table></figure><p>对象在 prototype 上的属性是共享的，即修改一个对象的某个属性，另一个对象对于的属性值也会改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p1.name = <span class="string">"test"</span></span><br><span class="line">p1.sayName() <span class="comment">// test</span></span><br><span class="line"></span><br><span class="line">p2.sayName() <span class="comment">// test</span></span><br></pre></td></tr></table></figure><h2 id="构造函数与原型模式"><a href="#构造函数与原型模式" class="headerlink" title="构造函数与原型模式"></a>构造函数与原型模式</h2><p>使用原型模式创建的对象共享 prototype 上的属性，那么当有些属性不想要对象之间共享的时候，就可以结合构造函数模式与原型模式来使用。这也是最常用的创建对象的方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span>  p1 = <span class="keyword">new</span> Person(<span class="string">"ahonn"</span>, <span class="number">21</span>)</span><br><span class="line">p1.sayName() <span class="comment">// "ahonn"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">"test"</span>, <span class="number">12</span>)</span><br><span class="line">p2.sayName() <span class="comment">// "test"</span></span><br></pre></td></tr></table></figure><h2 id="ES6-类"><a href="#ES6-类" class="headerlink" title="ES6 类"></a>ES6 类</h2><p>在 ES6 中有类似于 Java 创建对象的方式，即通过类来创建对象。ES6 中提供了 <code>class</code> 关键字，来声明一个类型，并如上面构造函数模式的方式一样使用 <code>new</code> 来声明对象。虽然可以使用类似 Java 中的 <code>class</code> 来声明，但实际上只是给构造函数与原型模式加上了语法糖，使得代码看起来更加易读。</p><p>还是 Person 类的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">"ahonn"</span>, <span class="number">21</span>)</span><br><span class="line">p.sayName() <span class="comment">// "ahonn"</span></span><br></pre></td></tr></table></figure></p><p>通过 <code>class</code> 关键字声明 Person 类，<code>constructor</code> 函数即为 Person 类的构造函数，类属性的初始化也在其中。需要在各个对象中共享的方法也写在 <code>class</code> 中，避免了原来定义在 <code>prototype</code> 上时的撕裂感。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工厂模式&quot;&gt;&lt;a href=&quot;#工厂模式&quot; class=&quot;headerlink&quot; title=&quot;工厂模式&quot;&gt;&lt;/a&gt;工厂模式&lt;/h2&gt;&lt;p&gt;在函数中创建 Object 对象，并为对象添加属性。函数返回添加属性之后的对象。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createPerson&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name, age&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o.name = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o.age = age&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  o.sayName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = createPerson(&lt;span class=&quot;string&quot;&gt;&quot;ahonn&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;21&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://www.ahonn.me/categories/technology/"/>
    
    
      <category term="前端" scheme="http://www.ahonn.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.ahonn.me/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数据类型判断</title>
    <link href="http://www.ahonn.me/2016/11/21/javascript-data-type-judgment/"/>
    <id>http://www.ahonn.me/2016/11/21/javascript-data-type-judgment/</id>
    <published>2016-11-21T07:07:49.000Z</published>
    <updated>2018-08-02T14:38:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始读之前没有读完的 underscore 的源码，刚把 Object 部分读完。对 JavaScript 中类型判断部分的总结。</p><h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h2><p>在进行类型判断时，使用到最多的当属 <code>Object.prototype.toString()</code>。</p><p><code>toString()</code> 方法返回一个代表该对象的字符串。每个对象都会继承 Object 上的 <code>toString</code> 方法，如果该方法没有被同名方法覆盖的话。使用 <code>toString()</code> 方法将会返回字符串 <code>&quot;[object type]&quot;</code>。其中 type 根据对象的类型的不同而不同。</p><p>关于 <code>Object.prototype.toString()</code> 的详细描述可以查看：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString" target="_blank" rel="noopener">Object.prototype.toString() - JavaScript | MDN</a></p><a id="more"></a><h2 id="使用-toString-判断类型"><a href="#使用-toString-判断类型" class="headerlink" title="使用 toString() 判断类型"></a>使用 toString() 判断类型</h2><p>由于 <code>toString()</code> 会返回带有类型信息的字符串，所以通常可以使用它来进行数据类型的判断。</p><p>underscore 中对一些数据类型的判断实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_.each([<span class="string">'Arguments'</span>, <span class="string">'Function'</span>, <span class="string">'String'</span>, <span class="string">'Number'</span>, <span class="string">'Date'</span>, <span class="string">'RegExp'</span>, <span class="string">'Error'</span>, <span class="string">'Symbol'</span>, <span class="string">'Map'</span>, <span class="string">'WeakMap'</span>, <span class="string">'Set'</span>, <span class="string">'WeakSet'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  _[<span class="string">'is'</span> + name] = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.call(obj) === <span class="string">'[object '</span> + name + <span class="string">']'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 <code>toString()</code> 函数的返回值判断类型，这里不使用 <code>typeof</code> 判断的原因是字面量与对象的返回值不同。</p><p>例如字符串字面量 <code>&quot;1&quot;</code> 通过 <code>typeof</code> 操作符返回的是 <code>&quot;string&quot;</code>，而字符串对象 <code>new String(&#39;1&#39;)</code> 通过 <code>typeof</code> 操作符返回的却是 <code>&quot;object&quot;</code>。所以通过 <code>Object.prototype.toString()</code> 来进行判断最为妥当。</p><h2 id="判断-NaN，null，undefined"><a href="#判断-NaN，null，undefined" class="headerlink" title="判断 NaN，null，undefined"></a>判断 NaN，null，undefined</h2><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>在 JavaScript 的 Number 类型中有这样一个特殊的存在，那就是 <code>NaN</code>。<code>NaN</code> 的意思是 Not-A-Number，即不是一个数字。当对无法转换为数字的变量进行数字转换时就会得到 <code>NaN</code>。<code>Nan</code> 还有一个特殊的性质，就是 <code>NaN === NaN</code> 返回的是 false。</p><p>所以对 NaN 的判断的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.isNaN = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.isNumber(obj) &amp;&amp; <span class="built_in">isNaN</span>(obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先判断是否为 Number 类型，排除隐式类型转换造成的误判。再使用 isNaN 函数判断是否为 NaN。</p><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>在 JavaScript 中有 <code>==</code> 与 <code>===</code> 两个相等操作符，后者为严格比较。<code>null == undefined</code> 的返回值是 true，所以不能使用这个来判断是否为 null。而 <code>null === undefined</code> 返回的是 false，因此使用严格相等哎判断是否为 null。而</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.isNull = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj === <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>判断变量是否为 <code>undefined</code>，很自然会想到使用 <code>foo === undefined</code> 的方式来判断。但是这样做是不安全的，在旧的浏览器版本上 <code>undefined</code> 是可以被重写的。这时使用上面那样判断会出现这种状况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以这种判断方式不被推荐，即使新版本的浏览器上无法重写 undefined。更推荐的方式是使用 <code>void 0</code> 来判断。<br>关于 <code>void 0</code> 与 <code>undefined</code> 可以参考我在知乎上的回答：<a href="https://www.zhihu.com/question/52645620/answer/131470539" target="_blank" rel="noopener">（void 0）在javascript中表示什么，和undefined有什么区别？</a></p><p>推荐的 undefined 判断实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.isUndefined = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断-Object"><a href="#判断-Object" class="headerlink" title="判断 Object"></a>判断 Object</h2><p>在 underscore 中对对象类型的判断是通过 <code>typeof</code> 来实现的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.isObject = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> type = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">return</span> type === <span class="string">'function'</span> || type === <span class="string">'object'</span> &amp;&amp; !!obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>typeof</code> 操作符在变量为 <code>null</code> 或者是对象时返回 <code>&quot;object&quot;</code>，在变量为函数对象时返回 <code>function</code>。</p><p>我们需要的是判断变量是否为对象，那么就需要排除 <code>null</code> 的情况，即将变量进行两次取反操作，将变量转换为 <code>Boolean</code> 类型。由于 <code>null</code> 会转换为 <code>false</code>，那么这样就可以排除 <code>null</code> 的干扰。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始读之前没有读完的 underscore 的源码，刚把 Object 部分读完。对 JavaScript 中类型判断部分的总结。&lt;/p&gt;
&lt;h2 id=&quot;Object-prototype-toString&quot;&gt;&lt;a href=&quot;#Object-prototype-toString&quot; class=&quot;headerlink&quot; title=&quot;Object.prototype.toString()&quot;&gt;&lt;/a&gt;Object.prototype.toString()&lt;/h2&gt;&lt;p&gt;在进行类型判断时，使用到最多的当属 &lt;code&gt;Object.prototype.toString()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt; 方法返回一个代表该对象的字符串。每个对象都会继承 Object 上的 &lt;code&gt;toString&lt;/code&gt; 方法，如果该方法没有被同名方法覆盖的话。使用 &lt;code&gt;toString()&lt;/code&gt; 方法将会返回字符串 &lt;code&gt;&amp;quot;[object type]&amp;quot;&lt;/code&gt;。其中 type 根据对象的类型的不同而不同。&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;Object.prototype.toString()&lt;/code&gt; 的详细描述可以查看：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Object.prototype.toString() - JavaScript | MDN&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术文章" scheme="http://www.ahonn.me/categories/technology/"/>
    
    
      <category term="前端" scheme="http://www.ahonn.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://www.ahonn.me/tags/JavaScript/"/>
    
  </entry>
  
</feed>
